<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-20JYM3ZFN0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-20JYM3ZFN0');
</script>
<title>Confidential Computing Proofs - ACM Queue</title>
<meta name="description" value />
<meta name="keywords" value="Privacy and Rights" />

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-P52H78L');</script>

<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="shortcut icon" href="favicon.ico" />
<script type="text/javascript" src="/js/jquery-1.2.6.min.js"></script>
<script type="text/javascript" src="/js/jquery.validate.min.js"></script>
<script type="text/javascript" src="/js/global.js"></script>

<link rel="alternate" type="application/rss+xml" title="All Queue Content RSS 2.0" href="/rss/feeds/queuecontent.xml" />
<link rel="alternate" type="application/rss+xml" title="Curmudgeon RSS 2.0" href="/rss/feeds/curmudgeon.xml" />
<link rel="alternate" type="application/rss+xml" title="Opinion RSS 2.0" href="/rss/feeds/opinion.xml" />
<link rel="alternate" type="application/rss+xml" title="Kode Vicious RSS 2.0" href="/rss/feeds/kodevicious.xml" />
<link rel="alternate" type="application/rss+xml" title="ACM TechNews RSS" href="https://www.infoinc.com/acm/TechNews.rss" />
<link rel="alternate" type="application/rss+xml" title="Washington Updates RSS" href="https://usacm.acm.org/weblog2/?feed=rss2" />
<link rel="alternate" type="application/rss+xml" title="RISKS Forum RSS" href="/rss/feeds/risksforum.xml" />
<link rel="alternate" type="application/rss+xml" title="AI RSS 2.0" href="/rss/feeds/ai.xml" />
<link rel="alternate" type="application/rss+xml" title="API Design RSS 2.0" href="/rss/feeds/apidesign.xml" />
<link rel="alternate" type="application/rss+xml" title="Bioscience RSS 2.0" href="/rss/feeds/bioscience.xml" />
<link rel="alternate" type="application/rss+xml" title="Blockchain RSS 2.0" href="/rss/feeds/blockchain.xml" />
<link rel="alternate" type="application/rss+xml" title="Business/Management RSS 2.0" href="/rss/feeds/business/management.xml" />
<link rel="alternate" type="application/rss+xml" title="Compliance RSS 2.0" href="/rss/feeds/compliance.xml" />
<link rel="alternate" type="application/rss+xml" title="Component Technologies RSS 2.0" href="/rss/feeds/componenttechnologies.xml" />
<link rel="alternate" type="application/rss+xml" title="Computer Architecture RSS 2.0" href="/rss/feeds/computerarchitecture.xml" />
<link rel="alternate" type="application/rss+xml" title="Concurrency RSS 2.0" href="/rss/feeds/concurrency.xml" />
<link rel="alternate" type="application/rss+xml" title="Cryptocurrency RSS 2.0" href="/rss/feeds/cryptocurrency.xml" />
<link rel="alternate" type="application/rss+xml" title="DSPs RSS 2.0" href="/rss/feeds/dsps.xml" />
<link rel="alternate" type="application/rss+xml" title="Data RSS 2.0" href="/rss/feeds/data.xml" />
<link rel="alternate" type="application/rss+xml" title="Databases RSS 2.0" href="/rss/feeds/databases.xml" />
<link rel="alternate" type="application/rss+xml" title="Debugging RSS 2.0" href="/rss/feeds/debugging.xml" />
<link rel="alternate" type="application/rss+xml" title="Development RSS 2.0" href="/rss/feeds/development.xml" />
<link rel="alternate" type="application/rss+xml" title="Distributed Computing RSS 2.0" href="/rss/feeds/distributedcomputing.xml" />
<link rel="alternate" type="application/rss+xml" title="Distributed Development RSS 2.0" href="/rss/feeds/distributeddevelopment.xml" />
<link rel="alternate" type="application/rss+xml" title="Education RSS 2.0" href="/rss/feeds/education.xml" />
<link rel="alternate" type="application/rss+xml" title="Email and IM RSS 2.0" href="/rss/feeds/emailandim.xml" />
<link rel="alternate" type="application/rss+xml" title="Embedded Systems RSS 2.0" href="/rss/feeds/embeddedsystems.xml" />
<link rel="alternate" type="application/rss+xml" title="Failure and Recovery RSS 2.0" href="/rss/feeds/failureandrecovery.xml" />
<link rel="alternate" type="application/rss+xml" title="File Systems and Storage RSS 2.0" href="/rss/feeds/filesystemsandstorage.xml" />
<link rel="alternate" type="application/rss+xml" title="Game Development RSS 2.0" href="/rss/feeds/gamedevelopment.xml" />
<link rel="alternate" type="application/rss+xml" title="Graphics RSS 2.0" href="/rss/feeds/graphics.xml" />
<link rel="alternate" type="application/rss+xml" title="HCI RSS 2.0" href="/rss/feeds/hci.xml" />
<link rel="alternate" type="application/rss+xml" title="Managing Megaservices RSS 2.0" href="/rss/feeds/managingmegaservices.xml" />
<link rel="alternate" type="application/rss+xml" title="Mobile Computing RSS 2.0" href="/rss/feeds/mobilecomputing.xml" />
<link rel="alternate" type="application/rss+xml" title="Networks RSS 2.0" href="/rss/feeds/networks.xml" />
<link rel="alternate" type="application/rss+xml" title="Object-Relational Mapping RSS 2.0" href="/rss/feeds/object-relationalmapping.xml" />
<link rel="alternate" type="application/rss+xml" title="Open Source RSS 2.0" href="/rss/feeds/opensource.xml" />
<link rel="alternate" type="application/rss+xml" title="Patching and Deployment RSS 2.0" href="/rss/feeds/patchinganddeployment.xml" />
<link rel="alternate" type="application/rss+xml" title="Performance RSS 2.0" href="/rss/feeds/performance.xml" />
<link rel="alternate" type="application/rss+xml" title="Power Management RSS 2.0" href="/rss/feeds/powermanagement.xml" />
<link rel="alternate" type="application/rss+xml" title="Privacy and Rights RSS 2.0" href="/rss/feeds/privacyandrights.xml" />
<link rel="alternate" type="application/rss+xml" title="Processors RSS 2.0" href="/rss/feeds/processors.xml" />
<link rel="alternate" type="application/rss+xml" title="Programming Languages RSS 2.0" href="/rss/feeds/programminglanguages.xml" />
<link rel="alternate" type="application/rss+xml" title="Purpose-built Systems RSS 2.0" href="/rss/feeds/purpose-builtsystems.xml" />
<link rel="alternate" type="application/rss+xml" title="Quality Assurance RSS 2.0" href="/rss/feeds/qualityassurance.xml" />
<link rel="alternate" type="application/rss+xml" title="RFID RSS 2.0" href="/rss/feeds/rfid.xml" />
<link rel="alternate" type="application/rss+xml" title="SIP RSS 2.0" href="/rss/feeds/sip.xml" />
<link rel="alternate" type="application/rss+xml" title="Search Engines RSS 2.0" href="/rss/feeds/searchengines.xml" />
<link rel="alternate" type="application/rss+xml" title="Security RSS 2.0" href="/rss/feeds/security.xml" />
<link rel="alternate" type="application/rss+xml" title="Semi-structured Data RSS 2.0" href="/rss/feeds/semi-structureddata.xml" />
<link rel="alternate" type="application/rss+xml" title="Social Computing RSS 2.0" href="/rss/feeds/socialcomputing.xml" />
<link rel="alternate" type="application/rss+xml" title="System Administration RSS 2.0" href="/rss/feeds/systemadministration.xml" />
<link rel="alternate" type="application/rss+xml" title="System Evolution RSS 2.0" href="/rss/feeds/systemevolution.xml" />
<link rel="alternate" type="application/rss+xml" title="Testing RSS 2.0" href="/rss/feeds/testing.xml" />
<link rel="alternate" type="application/rss+xml" title="Virtual Machines RSS 2.0" href="/rss/feeds/virtualmachines.xml" />
<link rel="alternate" type="application/rss+xml" title="Virtualization RSS 2.0" href="/rss/feeds/virtualization.xml" />
<link rel="alternate" type="application/rss+xml" title="Visualization RSS 2.0" href="/rss/feeds/visualization.xml" />
<link rel="alternate" type="application/rss+xml" title="VoIP RSS 2.0" href="/rss/feeds/voip.xml" />
<link rel="alternate" type="application/rss+xml" title="Web Development RSS 2.0" href="/rss/feeds/webdevelopment.xml" />
<link rel="alternate" type="application/rss+xml" title="Web Security RSS 2.0" href="/rss/feeds/websecurity.xml" />
<link rel="alternate" type="application/rss+xml" title="Web Services RSS 2.0" href="/rss/feeds/webservices.xml" />
<link rel="alternate" type="application/rss+xml" title="Workflow Systems RSS 2.0" href="/rss/feeds/workflowsystems.xml" />
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-6562869-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'stats.g.doubleclick.net/dc.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
<script type="text/javascript">
function plusone_vote( obj ) {
_gaq.push(['_trackEvent','plusone',obj.state]);
}
</script>
<style>
body {
	font-family: jaf-bernino-sans, 'Lucida Grande', 'Lucida Sans Unicode', 'Lucida Sans', Geneva, Verdana, sans-serif;
	color: #333;
	max-width: 100%;
}
div.container p {
	line-height: 1.65em;
}
h1 {
	font-size: 32px;
}
h3 {
	font-size: 18px;
}
h4 {
	font-size: 14px;
}

div.container {
	margin-left: auto;
	margin-right: auto;
}

div {
	margin: 64px;
//	max-width: 800px;
	position: relative;
}

@media only screen and (min-width: 1024px) {
	div {
		max-width: 800px;
	}
}

img {
    max-width: 100%;
    height: auto;
    width: auto\9; /* ie8 */
}
a {
	color: #009;
	text-decoration: none;
}
a:hover {
	text-decoration: underline;
}
hr {
	margin:64px;
}
label {
	font-size: 0.8em;
	color: #666;
}
input {
	color: #999;
}

/* NAVBAR */
.navbar {
//	position: fixed;
	background: #EEEEEE;
	top: -64px;
	z-index: 10000;
	width: 100%;
	clear: both;
	padding: 0px;
	margin: 0px;
	padding-top: 10px;
	padding-left: 10px;
	padding-right: 10px;
}

/*  SECTIONS  */
.section {
	clear: both;
	padding: 0px;
	margin: 0px;
}

/*  COLUMN SETUP  */
.col {
	display: block;
	float:left;
	margin: 1% 0 1% 1.6%;
}
.col:first-child { margin-left: 0; }


/*  GROUPING  */
.group:before,
.group:after {
	content:"";
	display:table;
}
.group:after {
	clear:both;
}
.group {
    zoom:1; /* For IE 6/7 */
}

/*  GRID OF THREE  */
.span_3_of_3 {
	width: 100%;
}
.span_2_of_3 {
	width: 66.1%;
}
.span_1_of_3 {
	width: 32.2%;
}

/*  GO FULL WIDTH AT LESS THAN 480 PIXELS */

@media only screen and (max-width: 480px) {
	.col {
		margin: 1% 0 1% 0%;
	}
}

@media only screen and (max-width: 480px) {
	.span_3_of_3 {
		width: 100%;
	}
	.span_2_of_3 {
		width: 100%;
	}
	.span_1_of_3 {
		width: 100%;
	}
}

.span_2_of_2 {
	width: 100%;
}

.span_1_of_2 {
	width: 49.2%;
}

/*  GO FULL WIDTH AT LESS THAN 480 PIXELS */

@media only screen and (max-width: 480px) {
	.span_2_of_2 {
		width: 100%;
	}
	.span_1_of_2 {
		width: 100%;
	}
}
</style>
<style>
body {
	font-size: 19px;
}
#form-search > .st-default-search-input {
	width: 170px;
  display: inline-block;
  height: 16px;
  padding: 7px 11px 7px 28px;
  border: 1px solid #bbb;
  border: 1px solid rgba(0,0,0,0.25);
  font-weight: 400;
  color: #3B454F;
  font-size: 14px;
  line-height: 16px;
  -webkit-box-sizing: content-box;
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-box-shadow: none;
  -moz-box-shadow: none;
  box-shadow: none;
  font-family: system, -apple-system, BlinkMacSystemFont, "Helvetica Neue", "Lucida Grande", sans-serif;
}


blockquote
{
    color: #666;
    font-size: 1.1em;
    background: none;
    border-left: .2rem solid #d3d3d3;

    display: block;
    padding: 20px 20px 10px 45px;
    margin: 20px 0;
    font-style: italic;

    margin-block-start: 1em;
    margin-block-end: 1em;
    margin-inline-start: 40px;
    margin-inline-end: 40px;

	font-family: Georgia, Palatino, "Palatino Linotype", Times, "Times New Roman", serif;
}

.ldq {
	display: block;
    padding-left: 10px;
    content: "\201C";
    font-size: 60px;
    position: relative;
    left: -50px;
    top: 0;
    height: 0;
    color: #7a7a7a;
}
code {
//	font-size:1.25em;
}
a {overflow-wrap: break-word;}
</style>
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<div class="container">
<div class="navbar">
<form id="form-search" name="searchform" onsubmit="return false;" style="float:right;">
<input type="text" class="st-default-search-input">
<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','UyYECD1kdsPnbHJtPyzG','2.0.0');
</script>
<br/>
<a href="issuedetail.cfm?issue=3695735" style="width:150px;font-size:0.7em;">Current Issue</a> &nbsp; <a href="pastissues.cfm" style="width:150px;font-size:0.7em;">Past Issues</a> &nbsp; <a href="topics.cfm" style="width:150px;font-size:0.7em;">Topics</a>
</form>
<a href="/"><img src="https://queue.acm.org/img/acmqueue_logo.gif" /></a>
</div>

<br/>
<label>September 10, 2024<br/><b><a class="descriptor" href="issuedetail.cfm?issue=3695735">Volume 22, issue 4 </a></b></label>
<p>

&nbsp;
<a href="https://portal.acm.org/citation.cfm?id=3689949">
<img src="img/icon_pdf.png" alt="Download PDF version of this article" />
PDF
</a>
</p>
<h1 class="hidetitle">Confidential Computing Proofs</h1>
<h2>An alternative to cryptographic zero-knowledge</h2>
<h3>Mark Russinovich, Cédric Fournet, Greg Zaverucha, Josh Benaloh, Brandon Murdoch, Manuel Costa</h3>
<p>Zero Knowledge Proofs (ZKP) are versatile cryptographic algorithms that yield strong privacy and integrity guarantees for computations on confidential data. For example, they have been used to realize anonymous credentials and as a building block in more complex applications, such as e-voting and decentralized finance. </p>
<p>Confidential Computing (CC) similarly yields privacy and integrity guarantees but follows a different system-based approach: Computations on confidential data are executed inside processors equipped with hardware mechanisms to isolate them from the rest of the platform and measure their code. The resulting attestation reports serve the same purpose as cryptographic proofs: They allow remote parties to verify that the computation was correctly executed without disclosing its confidential data. To facilitate the comparison with ZKPs, hardware-based attestation reports are referred to as Confidential-Computing Proofs (CCPs). This does not presume they are perfect mathematical proofs or interchangeable with ZKPs; in both cases, <i>argument</i> or <i>evidence</i> may be more accurate than <i>proof</i> but less common terminology.</p>
<p>This article attempts to relate the ZKP and CCP concepts. This is challenging since they are being developed by different communities, under very different trust assumptions, and both are still making fast progress and exploring new use cases. The article begins by describing how CCPs can be used to provide functionality similar to ZKPs. It then describes the tradeoffs they provide in terms of security, performance, usability, and scalability. It also illustrates them on a practical use case where both approaches apply. This side-by-side comparison is meant to facilitate discussions between ZKP and CC experts and be of use to those considering their practical deployment.</p>
<p>&nbsp;</p>
<h3>Introduction and Motivation</h3>
<p>Suppose that Alice is planning a dream vacation and wants to rent a luxury sailboat. Bob has a sailboat that he would like to rent, but he has specific criteria: A prospective renter must be at least 30 years old, have a suitable sailing license, have the funds to pay for the rental, and either have obtained insurance or be capable of self-insuring. Alice meets all of Bob's criteria but doesn't want to reveal specifics. She fears discrimination based on her identity and doesn't want to disclose her assets to self-insure the expensive boat.</p>
<p>Scenarios like this are not new. Fifty years ago, the only available approach was a trusted third party (TTP). An escrow agent can serve as a TTP as long as Alice trusts the agent to maintain her privacy and Bob trusts the agent to perform the necessary validations and vouch for Alice's credentials.</p>
<p>Forty years ago, zero-knowledge protocols were introduced that enable such "proofs" to be accomplished by replacing the TTP with mathematical assumptions. Since that time, our understanding of ZKPs has grown, their capabilities have expanded, and more efficient instantiations have been developed. Nevertheless, the ZKP process is still generally complex and cumbersome, and infrastructure to support scenarios such as Alice's rental simply doesn't exist.</p>
<p>Meanwhile, the hardware infrastructure has improved, and it is now a good time to re-examine whether a modern version of the TTP might be viable for some scenarios. Specifically, a variety of trusted execution environments (TEEs) is now available with the potential to solve Alice's rental needs more easily and efficiently by applying different assumptions. For example, a cloud provider might provide TEE services that Alice and Bob could use. Bob's requirements could be encoded into a program that Alice could inspect. If Alice and Bob are willing to accept the TEE assumptions, they can execute their agreement without even the cloud provider learning the details.</p>
<p>TEEs are not suitable for all proof applications. Their trust assumptions are different from those required for cryptographic ZKPs; many other tradeoffs are described in the side-by-side comparison shown in table 1. There are scenarios, however, where TEEs may provide an attractive alternative. To that end, this article introduces CCPs and explores their characteristics as a proof system.</p>
<img src="https://dl.acm.org/cms/attachment/html/10.1145/3689949/assets/html/fournet-t1.png" alt="Confidential Computing Proofs" />
<p>&nbsp;</p>
<h3>Defining Proofs</h3>
<p>Let's first specify what is meant by <i>proofs</i>, based on their existing cryptographic ideal functionality, regardless of their implementation. Consider two parties, a <i>prover</i> and a <i>verifier</i>, that agree on a property of interest, expressed as a pure Boolean function parameterized by public inputs (defining an <i>instance</i> of the property) and private inputs (providing <i>witnesses</i> for this instance).</p>
<p>Given an instance and witnesses such that the property holds (i.e., the Boolean function returns "true"), the prover can produce a <i>proof</i> to convince the verifier that it knows some witnesses for this instance, without disclosing its witnesses to the verifier.</p>
<p>A proof system is <i>sound </i>when no one can forge a proof for any instance without knowing a valid witness. It is <i>zero-knowledge</i> when the proof yields no information about the witnesses used by the prover (beyond the fact that they satisfy the instance). The focus here is on noninteractive, universally verifiable proofs, meaning that the prover generates the proof without communicating with the verifier, and any party can verify the proof given the property instance.</p>
<p>Intuitively, the property may describe a puzzle, the witness may describe a solution, and the proof may enable a party to convince others that it has solved the puzzle without disclosing its solution.</p>
<p>As an example, the public inputs may consist of a hash, a database query, and its result; the private inputs may comprise the whole contents of a database; and the function may verify that (1) the hash is the cryptographic digest of the database; and (2) evaluating the query on this database yields this result. The hash may be used by the verifier to authenticate the database (e.g., it may be given or signed by a trusted party) and to ensure the same database is used for answering a series of queries.</p>
<p>This example illustrates two common motivations for proofs.</p>
<p>• <b><i>Privacy for the prover. </i></b>Thanks to zero-knowledge, the prover controls precisely which information it reveals about the database, such as authorizing a series of queries it executes and proves. The prover has assurance that the proof reveals nothing more about the database than what can be learned from the responses to the queries.</p>
<p>• <b><i>Integrity and performance for the verifier.</i></b> Only the prover needs to run the computation and maintain the potentially large database. In contrast, the verifier operates only on the inputs, outputs, and proofs it cares about, which can be much simpler. This form of delegation is particularly useful for verifiers with limited capabilities, even when privacy is not a requirement.</p>
<p>The example also shows that many properties already involve some form of cryptography in their definition. Notably, public inputs often include cryptographic commitments to private data, which can be used, for example, to correlate multiple proofs sharing some of their private state—here, the whole state of the database.</p>
<p>&nbsp;</p>
<h3>Proofs Based on Cryptographic Algorithms</h3>
<p>The defining paper on ZKPs was published in 1985.<sup>6</sup> Noninteractive ZKPs, introduced soon after, are closely related to digital signatures.<sup>4</sup> In fact, some ZKPs such as Schnorr proofs yield practical signature schemes such as EdDSA (Edwards-curve Digital Signature Algorithm). Intuitively, a signature is a basic kind of proof, where the message and the verification key are public inputs, and the signing key is a private input. General ZKPs support arbitrary computations on their inputs.</p>
<p>Cryptographic proofs typically provide perfect information-theoretic privacy, meaning that the proof is statistically independent from the witness used to produce it; and computational soundness, meaning that an attacker with limited computing resources can forge a proof only with negligible probability. A common formalization of this guarantee is called <i>knowledge soundness</i>, where it is shown that an adversary who can output a proof accepted by the verifier must know a witness. (How you go about proving an adversary "knows" a witness is a fascinating question beyond the scope of this article; Oded Goldreich's book, <i>Foundations of Cryptography</i>, provides an accessible explanation.<sup>5</sup>)</p>
<p>Classic cryptographic ZKP constructions target simple, fixed properties, which can be expressed using, for example, linear or quadratic functions. Intuitively, the prover and the verifier both evaluate the function by computing on commitments instead of plaintext values, and the proof provides just enough auxiliary values to match some of these commitments against the function's public inputs and outputs. While the resulting proofs are linear in the size of the property and the overhead is large for both parties, these constructions are practical for many applications involving simple functions.</p>
<p>More-advanced ZKP constructions<sup>10,12</sup> involve more-succinct proofs, enabling the whole computation to be verified in a logarithmic, or even constant, number of operations on cryptographic commitments. While this is very efficient for verifiers, which sometimes can verify millions of operations at a cost similar to plain signature verification, this requires more-advanced algorithms and incurs additional costs for the prover.</p>
<p>Independently of core proof systems, there is much work to compile properties of interest (expressed for example in subsets of C or LLVM code) into the systems of linear or quadratic equations supported by these cryptographic algorithms. Even when the compilation applies to arbitrary properties, the resulting systems of equations can get much larger (hence, more costly to prove) than the source code of the property. This overhead is also hard to predict, as some operations are directly encoded, while others require an equation for every bit of their operands.</p>
<p>The prover typically executes the compiled property in a custom mode where each step of the computation produces witnesses, which are accumulated in the resulting proof. Since each step involves cryptographic computations (such as operations on elliptic curves), this generally entails several orders of magnitude of performance overhead compared with native execution.</p>
<p>&nbsp;</p>
<h3>Proofs based on Confidential Computing</h3>
<p>Confidential computing was introduced in 2014 with some of the first applications of Software Guard Extensions (SGX) enclaves.<sup>13</sup> It leverages hardware support for TEEs to protect the privacy and integrity of computation. The hardware ensures that the contents of a TEE are not visible to and cannot be modified by any party outside of the TEE, including hypervisors and other privileged software, and even those that may have access to the TEE's physical device.</p>
<p>A computation running inside a TEE can request it to generate an <i>attestation</i> of its code and initial configuration together with a message chosen at runtime. An attestation is usually implemented by signing a record that includes all this information using a unique, hardware-controlled key bound to the device and endorsed by a platform certificate provided by the hardware vendor. An attestation is effectively a proof that a TEE was started with this code and configuration and then received a request from this code to attest this message. Given the attestation, a verifier can independently review its code and configuration—for example, to confirm that the attested message meets some property.</p>
<p>CC is particularly useful to protect computations from their hosting environment, such as a cloud provider, and to let multiple parties jointly compute on data without sharing that data with the other parties. CC's attractiveness owes much to its practicality: Unlike advanced cryptographic computation techniques such as ZKP, multiparty computation, and homomorphic encryption, TEEs are highly compatible with existing software and usually have low performance overheads.</p>
<p>&nbsp;</p>
<h4>Achieving zero-knowledge with CC</h4>
<p>Continuing from our definition of proofs, suppose the prover and the verifier agree on a program that (1) reads an instance from its initial memory; (2) reads its witnesses from the untrusted host; (3) verifies the property; and (4) if the verification succeeds, requests and returns its attestation report as a proof that the property holds.</p>
<p>The prover creates a TEE that runs the program for this instance, then provides the witnesses and collects the resulting proof. This proof is just a signature on a specification of the property instance, rather than (a cryptographic encoding of) its execution.</p>
<p>CCP verification involves three checks, verifying that:</p>
<p>• The proof is a valid attestation report from a trusted hardware platform.</p>
<p>• The program correctly implements the property and matches the code measurement in the attestation report.</p>
<p>• The instance is correctly encoded in the initial-memory measurement in the attestation report.</p>
<p>At a high level, similar steps are involved in the verification of cryptographic proofs:</p>
<p>• The proof is valid with regard to public parameters obtained from a setup phase.</p>
<p>• The property is correctly encoded using these parameters.</p>
<p>• The instance is correctly encoded using these parameters.</p>
<p>If the hardware is trustworthy, CCPs are <i>sound</i> because the prover may obtain an attestation report that passes these three steps only by creating a TEE for this program and this instance, and then providing correct witnesses for it; and CCPs are zero-knowledge because they are signatures on measurements taken before the witnesses are provided to the TEE, hence, they do not carry any information about these witnesses.</p>
<p>&nbsp;</p>
<h4>From simple properties to general-purpose computations</h4>
<p>Since TEEs can run any program supported by their hardware processor, they offer flexibility in the way they produce proofs. As illustrated below, running larger and more complex programs may be more convenient, but also increases the amount of code that must be trusted by the verifier.</p>
<p>Instead of compiling the property to its own attested code, the prover can create a TEE that runs a small interpreter and takes both the property and its instance as attested inputs. This simplifies verification, since the code executed by the TEE can be reviewed and compiled once and for all. (This is the approach adopted later in this article.)</p>
<p>Instead of creating a TEE for each proof, the prover can create a TEE that handles multiple requests, each including an instance and its witnesses, and (assuming verification succeeds) returns an attestation for each instance.</p>
<p>So far, it is assumed that the prover trusted with the confidentiality of the requests acts as the local host for the TEE that produces its proofs; more generally, if the TEE runs on a remote server, its code may additionally include code to terminate a Transport Layer Security (TLS) connection, for example. It is also implicitly assumed that the property is a pure (deterministic, noninteractive) function; this restriction can be lifted by extending the TEE with system capabilities—for example, to interact with the host or even open connections to other parties.</p>
<p>&nbsp;</p>
<h3>Side-by-Side Comparison</h3>
<p>Table 1 compares CCPs and ZKPs in security, performance, and usability.</p>
<p>&nbsp;</p>
<h4>Security</h4>
<p>Both kinds of proofs—CCPs and ZKPs—involve some trust in cryptography, although ZKPs often involve more advanced cryptographic primitives and security assumptions. Hence, attestation reports usually rely on a traditional public-key infrastructure (PKI) for platform certificates, whereas ZKP schemes may rely on a trusted setup to produce and distribute public parameters.</p>
<p>Fundamentally, the soundness of CCPs is based on trust in the hardware, including its design, manufacture, supply chain, and operations (TEEs are potentially subject to glitches, physical attacks, and side-channel attacks). As an example, if a cosmic ray or overheating causes a bitflip that goes undetected, the CCP prover may yield an unsound proof, whereas the ZKP prover will yield a proof that fails to verify. </p>
<p>These risks can be partly mitigated by, for example, requiring that critical firmware updates have been installed; whitelisting the platform certificates of CPUs provisioned to a datacenter trusted to host the TEEs; and building some redundancy checks in the TEE code. All these requirements can be strictly enforced by verifiers as part of their attestation policies. More generally, modern CPUs are remarkably complex, but they are already trusted to some extent for most applications. Specifically, both for CCP and ZKP, the platform that runs the verifier is implicitly trusted.</p>
<p>For both kinds of proofs, the software TCB includes at least code for the verifier and code for the property to be verified. It is critical that the verifier review that the property is correctly implemented in all cases since (by privacy design) it won't be able to review the details of the run used to produce the proof. While code reviews can be challenging, this task can be facilitated by using formally verified code (notably for cryptography<sup>7</sup> and parsing<sup>11</sup>) and a code-transparency service.<sup>2</sup></p>
<p>Additional parts of the TCB are specific to the proof technology. For ZKP, they include the custom toolchain used, for example, to compile the property into an arithmetic circuit, as well as their library of cryptographic gadgets with handwritten arithmetic circuits. For CCP, they include a standard toolchain as well as any firmware and runtime support included in the TEE.</p>
<p>Regarding confidentiality, TEEs are intended to protect their code and data from all other parties, including their hosts. This goes beyond zero-knowledge, which (strictly speaking) protects the witnesses given access only to the proof but leaves the protection of the prover itself as a separate issue. More generally, CCP enables proofs where multiple parties each contribute their own private inputs to a TEE (after verifying its attestation) and the TEE finally returns selected results and proofs, whereas ZKP requires that each prover be trusted with all private inputs to produce its proof.</p>
<p>Using PQ (post-quantum) security as an example, let's now consider the agility of both systems should changes be required. With CCPs, this is conceptually straightforward—new standard PQ-safe algorithms are required for the attestation and the PKI—but it requires coordinated changes by many parties and, potentially, updated hardware, making it difficult to make such changes quickly. In contrast, ZKPs are purely software, and the prover and verifier libraries and parameters can be updated quickly. The changes are less straightforward, however, as PQ-safe zero-knowledge constructions are less efficient and mature.</p>
<p>&nbsp;</p>
<h4>Performance and scalability</h4>
<p>Prover performance clearly favors CCPs. Intuitively, TEEs run at the same native speed as any other computation on the CPU, with small additional fixed costs for creating and attesting the TEEs and linear costs for encrypting/decrypting data between the CPU and DRAM (dynamic random access memory). The relative creation overhead is negligible except for very short computations. Hardware encryption at line speed for all I/O can eliminate the linear overhead at a low cost in gate numbers and power budget on server CPUs (a small percentage) but may be more problematic on small devices. </p>
<p>Although initial TEEs suffered from system limitations (limiting, for example, the amount of memory they could use), more recent TEEs enable confidential computations to scale as well as plain computations with less than 10 percent overhead, making verifiable confidential computing a safe default for many applications.</p>
<p>Prover performance for ZKP is an active research topic, and steady progress continues to be made, but producing proofs is still several orders of magnitude more expensive than the computation itself,<sup>14</sup> and the most efficient provers require additional memory to keep intermediate values, keys, and precomputations. While recent algorithms provide excellent scalability in theory and can leverage powerful hardware to accelerate the production of proofs, these additional costs limit their general application and constrain the shape of the computations that can be proved in practice (expressed, for example, as iterated evaluations of the same arithmetic circuit).</p>
<p>Both CCP and ZKP yield succinct proofs that can be efficiently verified even on small devices, with sizes and verification performance approaching those expected of plain public-key cryptography, independent of the size of the computation being verified. For example, compressed attestation reports for Intel SGX and AMD SEV-SNP (Secure Encrypted Virtualization-Secure Nested Paging) are about 2,355 bytes and about 640 bytes verified on a laptop in 27 ms and 13 ms, respectively. Basic ZKPs may be as small as 64 bytes verified in less than 1 ms, whereas Nova compressed proofs for large circuits are about 9 KB verified in about 100 ms.<sup>10</sup></p>
<p>&nbsp;</p>
<h4>Ease of development and usability</h4>
<p>Custom code is required for proof verification: CCPs require specific libraries to process hardware attestations for the TEE platforms they trust, whereas ZKPs require specific libraries for their cryptographic algorithms. This code also needs to be updated and correctly configured, for example, with hardware vendor certificates for TEEs and public parameters for ZKPs. The availability and usability of these libraries are expected to improve over time.</p>
<p>On the prover side, CCP requires TEE-capable hardware, which was initially scarce and limited, whereas ZKP can be implemented purely in software. Major cloud providers now provide a range of managed TEE platforms, lowering this adoption barrier for at least cloud deployments and increasing their usability—for example, by handling firmware updates and platform certificate caches. Similarly, devices such as phones and laptops increasingly provide TEE capabilities.</p>
<p>ZKP uses custom compiler toolchains and initially required cryptographers to write custom application code. The situation is improving with the adoption of shared compilers and formats for arithmetic circuits, but their correct usage still involves substantial expertise and code refactoring. Whereas CCP implicitly supports stateful interactive computations that reuse existing runtimes and software stacks, including legacy and proprietary software, ZKP natively supports only pure computations and requires refactoring for the rest. Some ZKP systems make a different tradeoff between usability and performance by interpreting an existing architecture, such as an ISA or language runtime. Hence, for example, arbitrary machine code or Ethereum contracts may be supported but at a higher cost—their initial implementations could run only a few instructions per second.</p>
<p>&nbsp;</p>
<h3>Privacy-Friendly Paperwork and Credentials</h3>
<p>Let's return to the sailboat rental example outlined in the introduction. As the owner of the sailboat, Bob wants to verify that Alice has assorted credentials that meet his rental policy. These may include a valid form of identification such as a driver's license or passport; a proof of competency such as a sailing certification from an accredited school; a proof of financial soundness to pay for the rental; and either a certificate of insurance that covers some of the risks of sailing or a proof of having sufficient assets to self-insure.</p>
<p>Conveniently, such documents are increasingly available in digital formats, enabling rental agreements to be completed online. Digital driving licenses<sup>9</sup> and electronic insurance certificates, for example, are becoming more practical, thanks to ongoing standardization efforts.</p>
<p>At the same time, digital credentials come with new privacy risks. The casual dissemination of authenticated personal information, including age, gender, address, contact information, and ID pictures (and their potential aggregation by third parties) may facilitate identity theft, online tracking, and targeted advertising. In this case, Bob need not, and should not, care about the details of Alice's credentials, as long as he can verify that they satisfy his policy. Bob also need not learn whether Alice has obtained insurance or is self-insuring. Can Alice provide such a proof of policy compliance without disclosing these documents and sensitive financial data?</p>
<p>Figure 1 shows sample credentials presented by Alice to meet Bob's rental policy; additional credentials may include sailing school accreditations, certificates of insurance, proof of solvency, etc. As illustrated in figure 1, identity providers and other trusted authorities issue credentials and other documents in the form of signed sets of claims in some standard format (such as X.509 certificates or JSON web tokens). In practice, credentials may be delivered to the digital wallet of the credentials' owner on a personal device such as a phone or laptop, which is able to identify the owner using, for example, biometric authentication, before unlocking their credentials. </p>
<img src="https://dl.acm.org/cms/attachment/html/10.1145/3689949/assets/html/fournet1.png" alt="Confidential Computing Proofs" />
<p>Credentials usually include a signature from the issuer to protect their integrity. To present them to a third party, their owner may need to provide another signature to prove possession of the credentials and prevent their reuse. On the other hand, these credentials are not assumed to come with any custom privacy features, as would be the case with more advanced anonymous credentials.</p>
<p>For verifiers—in this example Bob, the boat owner—the policy to be satisfied may be expressed as a simple program or script, using a domain-specific policy language such as Rego or a subset of JavaScript. Figure 2 shows a sample policy enforcing Bob's requirements to rent his sailboat; the current date and session identifier bind the policy evaluation to Alice's request. As illustrated in figure 2, such policies may take as inputs some parameters such as a timestamp and a session ID. They may be created by the verifier and possibly endorsed by a regulator or a privacy watchdog. They should be simple enough to enable credential owners—in this example Alice—to review them and assess their privacy risks.</p>
<img src="https://dl.acm.org/cms/attachment/html/10.1145/3689949/assets/html/fournet2.png" alt="Confidential Computing Proofs" />
<p>Some basic policies may just require proving possession of a single credential with a given property, such as "My passport is valid for more than six months," without disclosing its full contents. Bob's sailboat renting policy involves more thorough verifications spanning multiple credentials. For example, Bob must verify that the same name is used in the documents presented to satisfy the policy, that they are all currently valid, and that each of them is signed by an authority that he trusts. This verification may in turn involve checks on auxiliary statements (omitted in the figure) such as the accreditation of Alice's sailing school or the certificate chain that endorses the DMV (Department of Motor Vehicles) key used for signing her driver's license.</p>
<p>While policy details should be carefully written by the verifier and may add up to dozens of lines of code, Alice can review policies on a case-by-case basis, considering the actual credentials she needs to present as well as the sensitivity of the information this may disclose. This review occurs before Alice decides to proceed, and no information is disclosed unless the policy requirements are actually satisfied.</p>
<p>On the other hand, neither the credential owners nor the verifiers need to review the underlying CCP or ZKP technology, in as much as its fixed TCB can be independently reviewed, regardless of the actual policy and credentials involved.</p>
<p>&nbsp;</p>
<h4>A simple CCP-based protocol</h4>
<p>This section describes a simple rental protocol between Alice and Bob using CCPs, then briefly outlines a similar protocol using ZKPs instead. The protocol involves three roles.</p>
<p>• Identity providers and other trusted authorities issue various credentials before the protocol starts; they are offline in the protocol and thus learn nothing about the use of their credentials.</p>
<p>• Alice acts as the prover. She holds her credentials in a digital wallet and controls their use; she presents some of these credentials upon legitimate requests from relying parties but wishes to protect her privacy. To this end, TEEs are created and controlled to produce proofs of their properties.</p>
<p>• Bob acts as the verifier. He guards access to resources (his boat), creates the corresponding authorization policies, and ensures compliance with these policies.</p>
<p>The details of Alice's wallet are unimportant here, assuming that it is trusted by Alice and its credential issuers, so the focus should be on the session between Alice and Bob to secure the boat rental. Figure 3 shows message flow for proving compliance to Bob's rental policy based on Alice's credentials without revealing their details. The proof of compliance is bound to the TLS connection and the current time. </p>
<img src="https://dl.acm.org/cms/attachment/html/10.1145/3689949/assets/html/fournet3.png" alt="Confidential Computing Proofs" />
<p>As shown in figure 3, they first establish a secure communication channel, which allows Alice to authenticate Bob and provides a fresh session identifier for this run of the protocol. (This is important to make the proof of compliance specific to this run, as otherwise Bob might reuse this proof for some other purpose such as renting another boat from a competitor.) Alice can then review the details of Bob's boat and fetch his rental policy (see figure 2). Assuming she finds this policy acceptable, she creates a TEE specifically for evaluating the policy on her actual credentials and attesting its result. The TEE returns a CCP, then terminates. Alice forwards the CCP to Bob, who verifies its validity; then they can finalize their transaction. As an optional final step of the protocol, Bob may issue a signed rental agreement, which may be added to Alice's wallet and used to fulfill further paperwork requirements—for example, applying for a cruising license.</p>
<p>&nbsp;</p>
<h4>What's in the software TCB?</h4>
<p>While conceptually simple, the TEE needs to run a substantial amount of trusted code for evaluating this kind of policy.</p>
<p>• As illustrated, the policy itself should be simple enough to be reviewed by all parties. This can be facilitated by using a high-level, domain-specific policy language. </p>
<p>• The rest of the code is complex but generic. It may include, for example, a basic language runtime for evaluating policy, libraries for cryptographic primitives and protocols, as well as code for parsing the formats for all supported credentials (including JSON for tokens and ASN.1 for X.509 certificates). This code can be tested, reviewed, or even formally verified once and for all.</p>
<p>&nbsp;</p>
<h4>Can ZKPs be used instead?</h4>
<p>A proof of policy compliance in this protocol can also be implemented purely in software, using a general-purpose succinct ZKP scheme instead of a CCP, without affecting the rest of the protocol (except for the proof format). Unfortunately, the "complex but generic" code described here complicates this task. For example, correctly parsing the name field out of a JSON token without revealing its position and length already requires custom techniques. As another example, Cinderella describes how to prove, in zero-knowledge, possession of a valid certificate chain<sup>1</sup> (a generic subtask for the example rental policy that involves ASN.1 parsing and signature verifications). Support for real-world Web certificate chains involved a custom arithmetic circuit with 3 million equations, which would require one to two minutes to prove with more recent proof systems.<sup>3</sup> </p>
<p>These difficulties are largely caused by legacy credential formats. More efficient protocols are now available for ZKP-friendly formats, but correctly implementing such security-critical operations, as well as a language runtime for policies, still requires cutting-edge ZKP handcrafting.</p>
<p>&nbsp;</p>
<h4>TEE placement and privacy considerations</h4>
<p>The TEE trusted with the credentials to evaluate policies and attest their results may either be located on the user's device (as shown in figure 3) or hosted in the cloud. Both approaches have their merits.</p>
<p>• When available, a personal TEE on a device protected with multifactor authentication mechanisms yields clear privacy guarantees and avoids the need for online services. It provides excellent credential protection for the device owner, but its TEE technology must be sufficiently trusted by the other parties (and their regulators).</p>
<p>Personal TEEs may also create additional privacy risks since verifiers may demand to identify a TEE's host in order to trust its attestations, such as to check if it has been revoked. (It is possible to use zero-knowledge to demonstrate that a TEE was not instantiated by a revoked host, but this approach is not widely supported.) </p>
<p>With proofs that are linkable in this way, relying parties can collude to track users across services and link their transactions to a durable identifier. While this risk seems acceptable for the example sailboat rental, there are many scenarios where anonymity or stronger pseudonymity is best for user privacy.</p>
<p>• Alternatively, using a CCP cloud service can provide uniform hardware protection (including physical datacenter protection) for a variety of client devices. A TEE hosted by a reputable cloud provider may be more trusted by verifiers and relying parties than a TEE on a personal device. It may also be convenient for policies that require online checks, such as interactive user sign-ins or lookups in certificate revocation lists. Regarding privacy, code reviews can be conducted to ensure that TEEs leak no information about client credentials besides the CCPs they produce. While it may still be possible to observe a client making a request to the CCP service and correlate it with a session between the client and the relying party, this risk can be mitigated at the transport level using, for example, Oblivious HTTP.</p>
<p>&nbsp;</p>
<h3>Conclusions</h3>
<p>Proofs are powerful tools for integrity and privacy, enabling the verifier to delegate a computation and still verify its correct execution, and enabling the prover to keep the details of the computation private. Both CCP and ZKP can achieve soundness and zero-knowledge but with important differences. CCP relies on hardware trust assumptions, which yield high performance and additional confidentiality protection for the prover but may be unacceptable for some applications. CCP is also often easier to use, notably with existing code, whereas ZKP comes with a large prover overhead that may be unpractical for some applications.</p>
<p>As these technologies gain wider adoption, it is likely that applications will increasingly leverage either or both CCP and ZKP for their computations. For example, ZKPs may be produced inside TEEs for additional prover protection, while TEEs may feature ZKPs for additional attestation privacy—for example, to hide the hardware identity of the TEE that runs the computation and produces its attestation.<sup>8</sup> From a wider perspective, individuals and governments are increasingly looking to safeguard data privacy, and we believe privacy-preserving proofs will help create a world where privacy is protected by default.</p>
<p>&nbsp;</p>
<h4>References</h4>
<p>1. Delignat-Lavaud, A., Fournet, C., Kohlweiss, M., Parno, B. 2016. Cinderella: turning shabby X.509 certificates into elegant anonymous credentials with the magic of verifiable computation. In <i>Proceedings of the IEEE Symposium on Security and Privacy</i>, 235?254; <a href="https://ieeexplore.ieee.org/document/7546505">https://ieeexplore.ieee.org/document/7546505</a>.</p>
<p>2. Delignat-Lavaud, A., Fournet, C., Vaswani, K., Clebsch, S., Riechert, M., Costa, M., Russinovich, M. 2023. Why should I trust your code? <i>Communications of the ACM 67</i> (1), 68?76; <a href="https://dl.acm.org/doi/10.1145/3624578">https://dl.acm.org/doi/10.1145/3624578</a>.</p>
<p>3. Ernstberger, J., Chaliasos, S., Kadianakis, G., Steinhorst, S., Jovanovic, P., Gervais, A., Livshits, B., Orrù, M. 2023. <a href="https://eprint.iacr.org/2023/1503.pdf">zk-Bench: a toolset for comparative evaluation and performance benchmarking of SNARKs</a>; <a href="https://eprint.iacr.org/2023/1503.pdf">https://eprint.iacr.org/2023/1503.pdf</a>.</p>
<p>4. Fiat, A., Shamir, A. 1986. How to prove yourself: practical solutions to identification and signature problems. In <i>Proceedings of Advances in Cryptology</i> (CRYPTO), 186?194; <a href="https://dl.acm.org/doi/10.5555/36664.36676">https://dl.acm.org/doi/10.5555/36664.36676</a>.</p>
<p>5. Goldreich, O. 2001. <i>Foundations of Cryptography, Volume 1: Basic Tools</i>. Cambridge University Press.</p>
<p>6. Goldwasser, S., Micali, S., Rackoff, C. 1985. The knowledge complexity of interactive proof-systems. In <i>Proceedings of the 17th Annual ACM Symposium on Theory of Computing</i> (STOC), 291?304; <a href="https://dl.acm.org/doi/10.1145/22145.22178">https://dl.acm.org/doi/10.1145/22145.22178</a>.</p>
<p>7. High Assurance Cryptographic Library ? HACL* and EverCrypt Manual; <a href="https://hacl-star.github.io/">https://hacl-star.github.io</a>.</p>
<p>8. Intel. 2021. Intel Enhanced Privacy ID (EPID) Security Technology; <a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-enhanced-privacy-id-epid-security-technology.html">https://www.intel.com/content/www/us/en/developer/articles/technical/intel-enhanced-privacy-id-epid-security-technology.html</a>.</p>
<p>9. ISO. 2021. ISO/IEC 18013-5:2021 ? Personal identification ? ISO-compliant driving license; <a href="https://www.iso.org/standard/69084.html">https://www.iso.org/standard/69084.html</a>.</p>
<p>10. Kothapalli, A., Setty, S., Tzialla, I. 2022. Nova: recursive zero-knowledge arguments from folding schemes. In <i>Proceedings of Advances in Cryptology</i>, 42nd Annual International Cryptology Conference (CRYPTO), 359?388; <a href="https://dl.acm.org/doi/abs/10.1007/978-3-031-15985-5_13">https://dl.acm.org/doi/abs/10.1007/978-3-031-15985-5_13</a>.</p>
<p>11. Ni, H., Delignat-Lavaud, A. Fournet, C., Ramananandro, T., Swamy, N. ASN1*: Provably correct, non-malleable parsing for ASN.1 DER. In <i>Proceedings of the 12th ACM SIGPLAN International Conference on Certified Programs and Proofs</i>, 275?289; <a href="https://dl.acm.org/doi/10.1145/3573105.3575684">https://dl.acm.org/doi/10.1145/3573105.3575684</a>.</p>
<p>12. Parno, B., Howell, J., Gentry, C., Raykova, M. 2013. Pinocchio: nearly practical verifiable computation. In <i>Proceedings of the IEEE Symposium on Security and Privacy</i>, 238?252; <a href="https://ieeexplore.ieee.org/document/6547113">https://ieeexplore.ieee.org/document/6547113</a>.</p>
<p>13. Schuster, F., Costa, M., Fournet, C., Gkantsidis, C., Peinado, M., Mainar-Ruiz, G., Russinovich, M. 2015. VC3: trustworthy data analytics in the cloud using SGX. In <i>Proceedings of the IEEE Symposium on Security and Privacy</i>, 38?54; <a href="https://dl.acm.org/doi/10.1109/SP.2015.10">https://dl.acm.org/doi/10.1109/SP.2015.10</a>. </p>
<p>14. Walfish, M., Blumberg, A. J. 2015. Verifying computations without reexecuting them: from theoretical possibility to near practicality. <i>Communications of the ACM 58</i> (2), 74?84; https://dl.acm.org/doi/10.1145/2641562. </p>
<p>&nbsp;</p>
<p><b>Mark Russinovich</b> is CTO of Microsoft Azure, where he leads technical strategy and architecture for Microsoft's cloud computing platform.</p>
<p><b>Cédric Fournet</b> is a senior principal research manager in Azure Research at Microsoft, Cambridge, UK. He is interested in security, privacy, cryptography, distributed systems, and formal verification. </p>
<p><b>Greg Zaverucha</b> is a software engineer and researcher at Microsoft Research. He does research in applied cryptography, implements cryptographic primitives and systems, and helps product teams use cryptography securely.</p>
<p><b>Josh Benaloh</b> is a senior cryptographer at Microsoft Research. His research focuses primarily on multiparty protocols, especially those supporting verifiable election technologies.</p>
<p><b>Brandon Murdoch</b> is a director of engineering in the Microsoft Security division, London, UK, where he leads work on authorization and decentralized identity, with focus on privacy-preserving technologies.</p>
<p><b>Manuel Costa</b> is a vice president and distinguished engineer at Microsoft, where he leads Azure Research on security and privacy. He is interested in advancing the state of the art in security and privacy, computer systems, and programming languages.</p>
<p>Copyright © 2024 held by owner/author. Publication rights licensed to ACM.</p>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'8cac29043c2a0a05',t:'MTcyNzYxNDg2OS4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script>
<p>
<img class="floatLeft" src="img/q stamp_small.jpg" width="26" height="45" alt="acmqueue"><br><br>
<em>Originally published in Queue vol. 22, no. 4</em>&#8212;
<br>
Comment on this article in the <a href="http://portal.acm.org/citation.cfm?id=3689949">ACM Digital Library</a>
</p>
<br/>

<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
<br/>

<br/>
<div class="g-plusone" data-size="small" data-annotation="inline" data-width="120"></div>

<script type="text/javascript">
	addthis_pub             = 'acm';
	addthis_logo            = 'http://queue.acm.org/img/logo_queue_small.gif';
	addthis_logo_background = '#ffffff';
	addthis_logo_color      = '000000';
	addthis_brand           = 'ACM Queue';
	addthis_options         = 'reddit, slashdot, facebook, favorites, email, delicious, digg, technorati, blinklist, furl, myspace, google, live, more';
</script>




<hr noshade size="1" />
More related articles:
<p>
<span>Raphael Auer, Rainer B&#246;hme, Jeremy Clark, Didem Demirag</span> - <a href="detail.cfm?id=3561796"><b>Mapping the Privacy Landscape for Central Bank Digital Currencies</b></a>
<br/>
As central banks all over the world move to digitize cash, the issue of privacy needs to move to the forefront. The path taken may depend on the needs of each stakeholder group: privacy-conscious users, data holders, and law enforcement.
</p>
<br/>
<p>
<span>Sutapa Mondal, Mangesh S. Gharote, Sachin P. Lodha</span> - <a href="detail.cfm?id=3546934"><b>Privacy of Personal Information</b></a>
<br/>
Each online interaction with an external service creates data about the user that is digitally recorded and stored. These external services may be credit card transactions, medical consultations, census data collection, voter registration, etc. Although the data is ostensibly collected to provide citizens with better services, the privacy of the individual is inevitably put at risk. With the growing reach of the Internet and the volume of data being generated, data protection and, specifically, preserving the privacy of individuals, have become particularly important.
</p>
<br/>
<p>
<span>Kallista Bonawitz, Peter Kairouz, Brendan McMahan, Daniel Ramage</span> - <a href="detail.cfm?id=3501293"><b>Federated Learning and Privacy</b></a>
<br/>
Centralized data collection can expose individuals to privacy risks and organizations to legal risks if data is not properly managed. Federated learning is a machine learning setting where multiple entities collaborate in solving a machine learning problem, under the coordination of a central server or service provider. Each client's raw data is stored locally and not exchanged or transferred; instead, focused updates intended for immediate aggregation are used to achieve the learning objective.
</p>
<br/>
<p>
<span>Mark Russinovich, Manuel Costa, C&#233;dric Fournet, David Chisnall, Antoine Delignat-Lavaud, Sylvan Clebsch, Kapil Vaswani, Vikas Bhatia</span> - <a href="detail.cfm?id=3456125"><b>Toward Confidential Cloud Computing</b></a>
<br/>
Although largely driven by economies of scale, the development of the modern cloud also enables increased security. Large data centers provide aggregate availability, reliability, and security assurances. The operational cost of ensuring that operating systems, databases, and other services have secure configurations can be amortized among all tenants, allowing the cloud provider to employ experts who are responsible for security; this is often unfeasible for smaller businesses, where the role of systems administrator is often conflated with many others.
</p>
<br/>
<hr noshade size="1" />
<hr noshade size="1" />
<p>
<a href="#"><img src="https://queue.acm.org/img/logo_acm.gif" /></a>
<br/>
&copy; ACM, Inc. All Rights Reserved.
</p>
</div>
</body>
</html>