<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">



<head>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-20JYM3ZFN0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-20JYM3ZFN0');
</script>



	  
	  <title>Intermediate Representations for the Datacenter Computer - ACM Queue</title>

	  

	  <meta name='description' value='' />
	  <meta name='keywords' value='Distributed Computing' />

<!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-P52H78L');</script>
<!-- End Google Tag Manager -->

<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="shortcut icon" href="favicon.ico" />

<script type="text/javascript" src="/js/jquery-1.2.6.min.js"></script>
<script type="text/javascript" src="/js/jquery.validate.min.js"></script>
<script type="text/javascript" src="/js/global.js"></script>



<!--
<link rel="alternate" type="application/rss+xml" title="Latest Queue Content RSS 2.0" href="/rss/feeds/latestitems.xml" />
-->
<link rel="alternate" type="application/rss+xml" title="All Queue Content RSS 2.0" href="/rss/feeds/queuecontent.xml" />
<link rel="alternate" type="application/rss+xml" title="Curmudgeon RSS 2.0"     href="/rss/feeds/curmudgeon.xml" />
<link rel="alternate" type="application/rss+xml" title="Opinion RSS 2.0"        href="/rss/feeds/opinion.xml" />
<link rel="alternate" type="application/rss+xml" title="Kode Vicious RSS 2.0"   href="/rss/feeds/kodevicious.xml" />
<link rel="alternate" type="application/rss+xml" title="ACM TechNews RSS"       href="https://www.infoinc.com/acm/TechNews.rss" />
<link rel="alternate" type="application/rss+xml" title="Washington Updates RSS" href="https://usacm.acm.org/weblog2/?feed=rss2" />
<link rel="alternate" type="application/rss+xml" title="RISKS Forum RSS"        href="/rss/feeds/risksforum.xml" />


<link rel="alternate" type="application/rss+xml" title="AI RSS 2.0"        href="/rss/feeds/ai.xml" />

<link rel="alternate" type="application/rss+xml" title="API Design RSS 2.0"        href="/rss/feeds/apidesign.xml" />

<link rel="alternate" type="application/rss+xml" title="Bioscience RSS 2.0"        href="/rss/feeds/bioscience.xml" />

<link rel="alternate" type="application/rss+xml" title="Blockchain RSS 2.0"        href="/rss/feeds/blockchain.xml" />

<link rel="alternate" type="application/rss+xml" title="Business/Management RSS 2.0"        href="/rss/feeds/business/management.xml" />

<link rel="alternate" type="application/rss+xml" title="Compliance RSS 2.0"        href="/rss/feeds/compliance.xml" />

<link rel="alternate" type="application/rss+xml" title="Component Technologies RSS 2.0"        href="/rss/feeds/componenttechnologies.xml" />

<link rel="alternate" type="application/rss+xml" title="Computer Architecture RSS 2.0"        href="/rss/feeds/computerarchitecture.xml" />

<link rel="alternate" type="application/rss+xml" title="Concurrency RSS 2.0"        href="/rss/feeds/concurrency.xml" />

<link rel="alternate" type="application/rss+xml" title="Cryptocurrency RSS 2.0"        href="/rss/feeds/cryptocurrency.xml" />

<link rel="alternate" type="application/rss+xml" title="DSPs RSS 2.0"        href="/rss/feeds/dsps.xml" />

<link rel="alternate" type="application/rss+xml" title="Data RSS 2.0"        href="/rss/feeds/data.xml" />

<link rel="alternate" type="application/rss+xml" title="Databases RSS 2.0"        href="/rss/feeds/databases.xml" />

<link rel="alternate" type="application/rss+xml" title="Debugging RSS 2.0"        href="/rss/feeds/debugging.xml" />

<link rel="alternate" type="application/rss+xml" title="Development RSS 2.0"        href="/rss/feeds/development.xml" />

<link rel="alternate" type="application/rss+xml" title="Distributed Computing RSS 2.0"        href="/rss/feeds/distributedcomputing.xml" />

<link rel="alternate" type="application/rss+xml" title="Distributed Development RSS 2.0"        href="/rss/feeds/distributeddevelopment.xml" />

<link rel="alternate" type="application/rss+xml" title="Education RSS 2.0"        href="/rss/feeds/education.xml" />

<link rel="alternate" type="application/rss+xml" title="Email and IM RSS 2.0"        href="/rss/feeds/emailandim.xml" />

<link rel="alternate" type="application/rss+xml" title="Embedded Systems RSS 2.0"        href="/rss/feeds/embeddedsystems.xml" />

<link rel="alternate" type="application/rss+xml" title="Failure and Recovery RSS 2.0"        href="/rss/feeds/failureandrecovery.xml" />

<link rel="alternate" type="application/rss+xml" title="File Systems and Storage RSS 2.0"        href="/rss/feeds/filesystemsandstorage.xml" />

<link rel="alternate" type="application/rss+xml" title="Game Development RSS 2.0"        href="/rss/feeds/gamedevelopment.xml" />

<link rel="alternate" type="application/rss+xml" title="Graphics RSS 2.0"        href="/rss/feeds/graphics.xml" />

<link rel="alternate" type="application/rss+xml" title="HCI RSS 2.0"        href="/rss/feeds/hci.xml" />

<link rel="alternate" type="application/rss+xml" title="Managing Megaservices RSS 2.0"        href="/rss/feeds/managingmegaservices.xml" />

<link rel="alternate" type="application/rss+xml" title="Mobile Computing RSS 2.0"        href="/rss/feeds/mobilecomputing.xml" />

<link rel="alternate" type="application/rss+xml" title="Networks RSS 2.0"        href="/rss/feeds/networks.xml" />

<link rel="alternate" type="application/rss+xml" title="Object-Relational Mapping RSS 2.0"        href="/rss/feeds/object-relationalmapping.xml" />

<link rel="alternate" type="application/rss+xml" title="Open Source RSS 2.0"        href="/rss/feeds/opensource.xml" />

<link rel="alternate" type="application/rss+xml" title="Patching and Deployment RSS 2.0"        href="/rss/feeds/patchinganddeployment.xml" />

<link rel="alternate" type="application/rss+xml" title="Performance RSS 2.0"        href="/rss/feeds/performance.xml" />

<link rel="alternate" type="application/rss+xml" title="Power Management RSS 2.0"        href="/rss/feeds/powermanagement.xml" />

<link rel="alternate" type="application/rss+xml" title="Privacy and Rights RSS 2.0"        href="/rss/feeds/privacyandrights.xml" />

<link rel="alternate" type="application/rss+xml" title="Processors RSS 2.0"        href="/rss/feeds/processors.xml" />

<link rel="alternate" type="application/rss+xml" title="Programming Languages RSS 2.0"        href="/rss/feeds/programminglanguages.xml" />

<link rel="alternate" type="application/rss+xml" title="Purpose-built Systems RSS 2.0"        href="/rss/feeds/purpose-builtsystems.xml" />

<link rel="alternate" type="application/rss+xml" title="Quality Assurance RSS 2.0"        href="/rss/feeds/qualityassurance.xml" />

<link rel="alternate" type="application/rss+xml" title="RFID RSS 2.0"        href="/rss/feeds/rfid.xml" />

<link rel="alternate" type="application/rss+xml" title="SIP RSS 2.0"        href="/rss/feeds/sip.xml" />

<link rel="alternate" type="application/rss+xml" title="Search Engines RSS 2.0"        href="/rss/feeds/searchengines.xml" />

<link rel="alternate" type="application/rss+xml" title="Security RSS 2.0"        href="/rss/feeds/security.xml" />

<link rel="alternate" type="application/rss+xml" title="Semi-structured Data RSS 2.0"        href="/rss/feeds/semi-structureddata.xml" />

<link rel="alternate" type="application/rss+xml" title="Social Computing RSS 2.0"        href="/rss/feeds/socialcomputing.xml" />

<link rel="alternate" type="application/rss+xml" title="System Administration RSS 2.0"        href="/rss/feeds/systemadministration.xml" />

<link rel="alternate" type="application/rss+xml" title="System Evolution RSS 2.0"        href="/rss/feeds/systemevolution.xml" />

<link rel="alternate" type="application/rss+xml" title="Testing RSS 2.0"        href="/rss/feeds/testing.xml" />

<link rel="alternate" type="application/rss+xml" title="Virtual Machines RSS 2.0"        href="/rss/feeds/virtualmachines.xml" />

<link rel="alternate" type="application/rss+xml" title="Virtualization RSS 2.0"        href="/rss/feeds/virtualization.xml" />

<link rel="alternate" type="application/rss+xml" title="Visualization RSS 2.0"        href="/rss/feeds/visualization.xml" />

<link rel="alternate" type="application/rss+xml" title="VoIP RSS 2.0"        href="/rss/feeds/voip.xml" />

<link rel="alternate" type="application/rss+xml" title="Web Development RSS 2.0"        href="/rss/feeds/webdevelopment.xml" />

<link rel="alternate" type="application/rss+xml" title="Web Security RSS 2.0"        href="/rss/feeds/websecurity.xml" />

<link rel="alternate" type="application/rss+xml" title="Web Services RSS 2.0"        href="/rss/feeds/webservices.xml" />

<link rel="alternate" type="application/rss+xml" title="Workflow Systems RSS 2.0"        href="/rss/feeds/workflowsystems.xml" />

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-6562869-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'stats.g.doubleclick.net/dc.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

<script type="text/javascript">
function plusone_vote( obj ) {
_gaq.push(['_trackEvent','plusone',obj.state]);
}
</script>



<style>
body {
	font-family: jaf-bernino-sans, 'Lucida Grande', 'Lucida Sans Unicode', 'Lucida Sans', Geneva, Verdana, sans-serif;
	color: #333;
	max-width: 100%;
}
div.container p {
	line-height: 1.65em;
}
h1 {
	font-size: 32px;
}
h3 {
	font-size: 18px;
}
h4 {
	font-size: 14px;
}

div.container {
	margin-left: auto;
	margin-right: auto;
}

div {
	margin: 64px;
//	max-width: 800px;
	position: relative;
}

@media only screen and (min-width: 1024px) {
	div {
		max-width: 800px;
	}
}

img {
    max-width: 100%;
    height: auto;
    width: auto\9; /* ie8 */
}
a {
	color: #009;
	text-decoration: none;
}
a:hover {
	text-decoration: underline;
}
hr {
	margin:64px;
}
label {
	font-size: 0.8em;
	color: #666;
}
input {
	color: #999;
}

/* NAVBAR */
.navbar {
//	position: fixed;
	background: #EEEEEE;
	top: -64px;
	z-index: 10000;
	width: 100%;
	clear: both;
	padding: 0px;
	margin: 0px;
	padding-top: 10px;
	padding-left: 10px;
	padding-right: 10px;
}

/*  SECTIONS  */
.section {
	clear: both;
	padding: 0px;
	margin: 0px;
}

/*  COLUMN SETUP  */
.col {
	display: block;
	float:left;
	margin: 1% 0 1% 1.6%;
}
.col:first-child { margin-left: 0; }


/*  GROUPING  */
.group:before,
.group:after {
	content:"";
	display:table;
}
.group:after {
	clear:both;
}
.group {
    zoom:1; /* For IE 6/7 */
}

/*  GRID OF THREE  */
.span_3_of_3 {
	width: 100%;
}
.span_2_of_3 {
	width: 66.1%;
}
.span_1_of_3 {
	width: 32.2%;
}

/*  GO FULL WIDTH AT LESS THAN 480 PIXELS */

@media only screen and (max-width: 480px) {
	.col {
		margin: 1% 0 1% 0%;
	}
}

@media only screen and (max-width: 480px) {
	.span_3_of_3 {
		width: 100%;
	}
	.span_2_of_3 {
		width: 100%;
	}
	.span_1_of_3 {
		width: 100%;
	}
}

.span_2_of_2 {
	width: 100%;
}

.span_1_of_2 {
	width: 49.2%;
}

/*  GO FULL WIDTH AT LESS THAN 480 PIXELS */

@media only screen and (max-width: 480px) {
	.span_2_of_2 {
		width: 100%;
	}
	.span_1_of_2 {
		width: 100%;
	}
}
</style>


<style>
body {
	font-size: 19px;
}
#form-search > .st-default-search-input {
	width: 170px;
  display: inline-block;
  height: 16px;
  padding: 7px 11px 7px 28px;
  border: 1px solid #bbb;
  border: 1px solid rgba(0,0,0,0.25);
  font-weight: 400;
  color: #3B454F;
  font-size: 14px;
  line-height: 16px;
  -webkit-box-sizing: content-box;
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-box-shadow: none;
  -moz-box-shadow: none;
  box-shadow: none;
  font-family: system, -apple-system, BlinkMacSystemFont, "Helvetica Neue", "Lucida Grande", sans-serif;
}


blockquote
{
    color: #666;
    font-size: 1.1em;
    background: none;
    border-left: .2rem solid #d3d3d3;

    display: block;
    padding: 20px 20px 10px 45px;
    margin: 20px 0;
    font-style: italic;

    margin-block-start: 1em;
    margin-block-end: 1em;
    margin-inline-start: 40px;
    margin-inline-end: 40px;

	font-family: Georgia, Palatino, "Palatino Linotype", Times, "Times New Roman", serif;
}

.ldq {
	display: block;
    padding-left: 10px;
    content: "\201C";
    font-size: 60px;
    position: relative;
    left: -50px;
    top: 0;
    height: 0;
    color: #7a7a7a;
}
code {
//	font-size:1.25em;
}
a {overflow-wrap: break-word;}
pre {
	overflow-x: auto;
	white-space: pre-wrap;
	word-wrap: break-word;
}
</style>
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>

<body>
<!-- Google Tag Manager (noscript)
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-P52H78L"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
 End Google Tag Manager (noscript) -->



<div class=container>
	<div class="navbar">
		<form id="form-search" name="searchform" onsubmit="return false;" style='float:right;'>
				<input type="text" class="st-default-search-input">
<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','UyYECD1kdsPnbHJtPyzG','2.0.0');
</script>
				<br />
			
			<a href="issuedetail.cfm?issue=3727151" style='width:150px;font-size:0.7em;'>Current Issue</a> &nbsp; <a href="pastissues.cfm" style='width:150px;font-size:0.7em;'>Past Issues</a> &nbsp; <a href="topics.cfm" style='width:150px;font-size:0.7em;'>Topics</a>
			
		</form>
		<a href='/'><img src='https://queue.acm.org/img/acmqueue_logo.gif' /></a>

	</div>

<!--
<p style='text-align:center;'>
<a href='/app/' target='_new'><img src='/app/2021_03-04_lrg.png' with=90 height=120 style='float:right;width:90px;height:120px;' alt='March/April 2021 issue of acmqueue' /></a>
<b><a href='/app/'>The March/April 2021 issue of acmqueue is out now</a></b>
<br />
<br />
<a href='https://cdn.coverstand.com/3rd_pty/acm/login.html?&btx_i=705849'>Subscribers and ACM Professional members login here</a>
<br clear=all />
<hr style='display:block;color:red;margin:5px;' />
</p>
-->
<br />



<label>February 3, 2025<br /><b><a class="descriptor" href="issuedetail.cfm?issue=3714453">Volume 22, issue 6 </a></b></label>


<p>
<!-- // Check for existence of associated MP3 file-->

 &nbsp;
	
			<a href="https://portal.acm.org/citation.cfm?id=3712258">
				<img src="img/icon_pdf.png" alt="Download PDF version of this article" />
				PDF
			</a>
		
</p>


 
  <h1 class="hidetitle">Intermediate Representations for the Datacenter Computer</h1> 
  <h2>Lowering the Burden of Robust and Performant Distributed Systems</h2> 
  <h3>Achilles Benetopoulos</h3> 
  <p>We have reached a point where distributed computing is ubiquitous. In-memory application data size is outstripping the capacity of individual machines, necessitating its partitioning over clusters of them; online services have high availability requirements, which can be met only by deploying systems as collections of multiple redundant components; high durability requirements can be satisfied only through data replication, sometimes across vast geographical distances. While it has arguably never been easier to procure the necessary hardware—thanks to the prevalence of public clouds—and to <i>deploy</i> distributed applications with a variety of tools from cluster orchestrators such as Kubernetes to newer paradigms such as functions-as-a-service, building correct and efficient distributed solutions largely remains an individual exercise.</p> 
  <p>There is a baseline set of concerns that need to be addressed for any distributed program to behave correctly; at the same time, these concerns pertain to the aspects of distributed computing that represent the most significant departure from the single-node programs that application programmers are comfortable implementing, and can be the hardest to address correctly. Getting some of these wrong—like communication and the coordination of distributed action in the presence of partial failure, or access and modification to shared data at a distance—can affect system correctness; others—like appropriate data partitioning and placement—will not affect the validity of a program's results, but getting them wrong can have catastrophic effects on system performance.</p> 
  <p>It seems desirable to be able to isolate these issues from user applications, and to address them at the infrastructure level so that diverse programs running on top of a distributed computing substrate can all reap the benefits. Arguably, big-data frameworks such as Hadoop MapReduce and Apache Spark are the most successful attempts to this end, enabling programmers with an appetite for big data to leverage the power of clusters of machines to speed up large-scale computations. Their domain-specific programming abstractions isolate the application programmer from the mechanisms of load-balancing computation across hosts and moving data between them, as well as from managing host failures. Their domain specificity, however, makes them unsuitable for a large domain of applications such as long-term data storage or web-application back ends.</p> 
  <p>More typically, in practice, distributed systems arise as a composition of various subsystems, as illustrated by modern service-oriented architectures. Similar to the Unix model, functionality is composed at the granularity of a "process"—large-scale programs are built up by taking smaller programs (data stores like Cassandra or etcd, message brokers like RabbitMQ, etc.) that are designed to solve a specific problem in isolation and composing them by introducing appropriate plumbing for an application to consume them and coordinate across them. This paradigm presents a major tradeoff for the programmer: In return for having much more control over the details of how the system works, they are now exposed to the full breadth of distributed-systems pitfalls.</p> 
  <p>Some recent systems try to strike a balance between these two extremes by striving to provide the ease of use of the big data frameworks without unnecessarily restricting the kinds of programs that can reasonably be expressed in them, and they do so by focusing on facilitating common <i>patterns</i> of distributed computation. One such example is <a href="https://temporal.io/">Temporal</a>,<sup>9</sup> a distributed execution platform in which user programs are expressed as workflows of individual steps that interact using the familiar async/await paradigm. Programmers express their workflows using Temporal's APIs, and they are guaranteed that these workflows will run correctly and to completion in the presence of any kind of failure. </p> 
  <p>At the core of Temporal is its durable workflow abstraction, which captures the sequence of steps that need to be taken as a response to a request for computation; the workflow abstraction is in some sense the target against which the user writes their program, but it effectively isolates them from execution details, which are determined entirely by the Temporal platform. Temporal itself doesn't care about the exact code running in each step of the workflow; the only details it needs to be aware of is what it is allowed to do in case it encounters a failure.</p> 
  <p>&nbsp;</p> 
  <h3>Decoupling Application Logic and Distributed Coordination</h3> 
  <p>As demonstrated by some of these systems, the right choice of abstractions, such as <a href="https://www.usenix.org/system/files/conference/nsdi12/nsdi12-final138.pdf">Spark's resilient distributed datasets</a><sup>10</sup> or Temporal's durable workflows, can allow the clean decoupling of business logic from the orchestration of distributed outcomes. By taking care of orchestration and communication details on the users' behalf, systems like Temporal can lower the barrier to entry and allow application programmers to leverage fleets of computers without becoming experts in distributed computing. At the same time, this separation of concerns is only the first (necessary) step in assisting programmers who navigate the domain of distributed computing. We should use the aforementioned decoupling as a basis for eliminating more than just coordination concerns (e.g., shared data consistency) from the programmer's plate.</p> 
  <p>To this end, the focus should be on providing language-independent, reusable abstractions for facilitating correct distributed outcomes with minimal user involvement. Language independence is a key requirement, as it allows maximizing the utility that can be derived from this imagined piece of infrastructure. This requirement leads us to looking to compiler research for inspiration. </p> 
  <p>Over the past 15 years, there has been renewed interest in exploring new programming languages and paradigms, thanks largely to the existence of projects like LLVM, and more specifically the ability to compile down drastically different languages into a unified IR (intermediate representation) that the rest of the compiler toolchain operates over in a way that is agnostic to whatever front-end language produced it. This IR fully captures the details of user programs but does so for an idealized, nonexistent machine; the compiler is free to apply sometimes radical transformations and optimizations in this closed representation according to an internal rule set and can subsequently translate the optimized program for this idealized virtual machine into concrete assembly code for a target architecture.</p> 
  <p>If the datacenter is believed to be a computer,<sup>1</sup> then this question should be asked: Is there an idealized IR for it? This IR would necessarily be distinct from that used by a traditional compiler, because the "fundamental" operations of the (idealized) distributed computer are different than those of a single CPU. For example, whereas one of the most important aspects of a single-machine program revolves around loads and stores from memory, at the cluster level they revolve around when and how cross-machine communication should happen.</p> 
  <p>As a basis for this IR, we can look to distributed dataflow, in which large-scale programs are expressed as directed acyclic graphs where each node represents a single-node piece of functionality (e.g., a function call), called an operator, and edges represent data dependencies between those fragments of compute. In this way, all distribution-related concerns are isolated at the edges between operators. Core business logic, which is what the application programmer is a domain expert on, is distribution unaware; what happens along the edges can be the purview of an orchestration and distributed execution layer.</p> 
  <p>This separation between local and distributed code encourages us to imagine infrastructure that translates the distributed interactions embedded in user programs into an intermediate distributed dataflow representation that is subsequently "compiled" down to a concrete orchestration of distributed computation. The program's representation in this IR captures the programmer's intent—how data flows through the system and the transformations it is subject to—while providing a runtime leeway in making concrete decisions around placement and network interactions. </p> 
  <p>Components written in distinct languages can reference and use each other, with their interactions modifying and extending the underlying dataflow graph. The existence of such an IR would also enable a unified runtime as the computation substrate for all clusterwide computing. This article highlights some of the benefits anticipated under this model by focusing on two experimental systems in this line of research.</p> 
  <p>&nbsp;</p> 
  <h3>Two Academic Examples</h3> 
  <p>This section looks at two active academic research projects that aim to isolate application programmers from mechanistic distribution details through high-level representations of distributed computation. The first such project is <a href="https://hydro.run/">Hydro</a>,<sup>7</sup> a language stack developed at UC Berkeley with the goal of providing a common execution substrate to distributed programs written in a multitude of programming languages. The second one is Magpie, a new distributed single-level store and runtime being developed at UC Santa Cruz.</p> 
  <p>&nbsp;</p> 
  <h4>Hydro</h4> 
  <p>The Hydro project consists of a compiler stack that aims to translate distributed programs written in a multitude of languages into a unified, distribution-aware IR that can be executed by the Hydro runtime. In the future envisioned by the project, programs will be written in a language of the programmer's choice, leveraging Hydro's library and APIs; at the core of Hydro's compilation process are multiple levels of intermediate representations, each with a different purpose.</p> 
  <p>The first-level IR, Hydrologic, is a declarative language that captures a high-level logical plan of the target distributed computation; Hydrologic programs represent the programmers' intent with respect to how application data is meant to be transformed and propagated through the system but omit concrete runtime details such as communication between hosts or data placement and replication strategies.</p> 
  <p>Hydrologic programs are then transformed to a second-level IR called Hydroflow—Hydroflow programs are semantically equivalent to the Hydrologic programs they originate from, in the sense that they produce identical outcomes but are meant to be single-threaded, single-node programs that can be executed by Hydro's runtime. This base Hydroflow representation is then used by the final step of the compilation process whose job it is to translate and optimize the single-node Hydroflow programs into potentially multihost asynchronous dataflow programs. This final configuration and optimization step takes into account high-level objectives specified by users (e.g., the maximum number of host failures the program should tolerate, or per-endpoint latency service-level objectives) in a declarative form, which are used to discover an appropriate configuration of the user program that can then be deployed on a cluster and executed by Hydro's runtime.</p> 
  <p>In a 2023 paper, <a href="https://hydro.run/papers/joe-applied-2023.pdf">Hellerstein et al.</a><sup>6</sup> illustrate the power of separating application logic from distributed orchestration logic by walking the reader through an implementation of the infamous "shopping cart" example from the <a href="https://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf">Dynamo paper</a><sup>4</sup> for Hydro. As part of the example, the authors illustrate how the same high-level program can be translated into a variety of concrete distributed programs; more specifically, different decisions on the placement of edges that represent network communication in the final dataflow graph can make the difference between client-side batching and server-side batching of intermediate shopping cart states. The choice of variant depends on the tradeoffs the application programmer seeks to navigate—the authors argue that if the programmer's primary concern is tolerating client failures, then server-side batching is the preferable deployment configuration; however, if the programmer is operating under strict requirements around user privacy and data ownership, then the right choice is the solution that isolates intermediate state on a user's client and reveals information to a server only when the user chooses.</p> 
  <p>The ability to arrive at distinct implementations with significantly different communication characteristics without requiring any implementation-level rewrites is a direct corollary of the decoupling of the "logical plan" of a distributed program (which encodes the programmer's intent for computation) from the concrete deployment of said program, which is augmented with mechanisms that accomplish said intent at execution time under the realities of large-scale distribution. Today, all such tradeoffs would have to be considered at application-design time, as moving from one variant to the other would necessitate potentially complex application rewrites.</p> 
  <p>While Hydro is still in a relatively nascent state, the results that have come out of this research highlight the power of lifting distributed-systems interactions into a high-level "logical plan" that is amenable to rewrites and optimizations and point the way toward some powerful futures. More specifically, given that distributed programs get translated into a common representation, and the components that compose for the end-to-end execution of distributed programs become, in essence, part of the same program, we can imagine a future of opportunities for whole-program, cross-component optimizations through rewrites and manipulations of the underlying dataflow graph, similar to work published in 2024 by <a href="https://dl.acm.org/doi/pdf/10.1145/3639257">Chu et al</a>., which focuses on optimizing Paxos through rule-driven rewrites.<sup>3</sup></p> 
  <p>&nbsp;</p> 
  <h4>Magpie</h4> 
  <p>Magpie is a distributed single-level store and runtime in which application data is packed into objects (arena-like typed regions of memory) that reside in a global address space. Programs are compositions of functions that operate over that data; these compositions form a dataflow graph that is dynamically expanded at runtime. This article focuses on how Magpie distributes user programs without programmer intervention or guidance. (The implementation of Magpie and its execution model will be described in more detail in a future publication.)</p> 
  <p>Importantly, both data and code in Magpie are mobile. Objects are structured in such a way as to be <a href="https://www.usenix.org/system/files/atc20-bittman.pdf">transparently relocatable between hosts</a>.<sup>2</sup> Functions are location-transparent, in the sense that there is nothing in their implementation that relies on specific placement decisions, and distribution-unaware, in the sense that they are not allowed to engage in any form of distributed coordination. They are queries and transformations over local data, guaranteed to execute from start to finish on a single machine without preemption. Furthermore, each function is executed under ACID (atomicity, consistency, isolation, durability) semantics, subject to the user's requirements around data consistency. The Magpie runtime itself fills the role of both the control and data planes for a given application.</p> 
  <p>Code and data mobility enables Magpie to take an extreme late-binding approach when it comes to executing user code. The aforementioned static task graph encodes information around data and control dependencies that need to be respected, but it omits concrete execution details such as activation sites, communication details, or even the potential parallelism available for the computation; as the static graph is expanded at runtime, and the computation's real set of data dependencies is discovered, the runtime orchestrates data and code movement so that it can execute each of these functions as guaranteed, trying to take full advantage of the available parallelism in the cluster (subject to the structure of the user's program) and minimizing the need for expensive distributed coordination like distributed commit. One of the reasons why the Magpie runtime can play such an effective role is the ability to perform lightweight interposition at the edges of the dataflow graph and introspect on each function's data dependencies and the operational state of the cluster while having full control over the application's data plane.</p> 
  <p>Lifting arbitrary programs into the dataflow representation means concerns that were previously thought to be exclusively the programmer's responsibility can now be subsumed and addressed entirely in the infrastructure. User programs can be transparently scaled up through automatic parallelization, which is enabled by the ability to introspect on their functional dependencies, coupled with the isolation properties of the transactional execution model. Visibility into application data access patterns is also critical in scaling out computation over a cluster of machines, as it allows for dynamically readjusting the placement of compute and data on the fly in such a way as to minimize distributed coordination and network interactions between components in an affinity-respecting manner. This amortizes network costs and takes advantage of temporal working sets in applications, while also effectively balancing observed load.</p> 
  <p>The task-graph abstractions also enable a powerful composition model, moving beyond the Unix-like model of service composition that was sketched in the introduction. In this model, infrastructure components such as key/value stores or pub/sub systems are implemented as user-level libraries, which can then be consumed by higher-level programs through functional interfaces they expose. </p> 
  <p>This model enables the development and reuse of established infrastructure—something like the microservice model—but the separation between components, critical for organizing large software artifacts, is manifest only in application-code structure; at runtime, the functionality of all components is translated to well-defined compositions of "operators" in the language of dataflow. In turn, this allows the runtime to potentially isolate the execution of individual workflows or programs entirely on a single machine, providing extremely fast distribution-free execution to user programs that, using more traditional approaches such as RPC (remote procedure call), might involve gratuitous communication over the network in the application's critical path.<sup>8</sup></p> 
  <p>The benefits of ownership of the data and control planes extend beyond application performance concerns. For any operation that the runtime executes, there is a complete causal record of their observed effects, allowing us to easily answer questions around how a computation unfolded over time, as a response to a user request, or what data changed and what the modifications were. This record can serve as the basis for powerful debugging tools. For example, when an application encounters a bug, instead of trying to synthesize signals from a variety of tools like application logs and distributed traces to help you work backwards toward the root cause of the issue, you could gather all log records for the period of time in which the problem under investigation appeared and use them as input to a single-node deterministic cluster simulator that replays the logs and lets the user do time-travel debugging to isolate the root cause of the violation, in service of further troubleshooting.</p> 
  <p>&nbsp;</p> 
  <h4>Distinct IRs</h4> 
  <p>Hydro and Magpie differ significantly in their value propositions. For example, Hydro builds on recent research in properties such as <a href="https://dl.acm.org/doi/pdf/10.1145/3369736">monotonicity</a><sup>5</sup> and coordination avoidance and seeks to exploit these properties as opportunities for optimizing user programs at compile time. Magpie provides correctness and performance guarantees for arbitrary user programs that have been translated into its programming model but does not try to <i>automatically</i> optimize them by changing their structure; rather, it assumes that the optimal deployment configuration of a user program cannot be known ahead of time and therefore seeks optimization opportunities at runtime.</p> 
  <p>Despite these differences, both Hydro and Magpie represent a clean cut from existing paradigms that seek to augment traditional, single-node programming with constructs for the coordination of distributed activity; instead, they embrace the adoption of new programming models for the development of robust-by-construction, high-performance distributed programs. Critically, they serve to illustrate both the viability of deriving an IR for the datacenter computer, as both have arrived at using a form of distributed dataflow as the main abstraction for modeling arbitrary distributed computation, as well as the potential impact of such a fundamental abstraction. This enables both systems to eliminate concrete distribution concerns from user applications and to facilitate their correct and efficient execution.</p> 
  <p>&nbsp;</p> 
  <h3>Future Opportunities</h3> 
  <p>Many questions are left to be answered before making definitive claims about the viability of rewriting existing applications for the experimental systems highlighted here, but in closing, let me sketch a path for the incremental adoption and evaluation of these systems, and describe how this incremental path can help in addressing an increasingly relevant problem, which is easily taking advantage of heterogeneous compute in the cloud.</p> 
  <p>Both Hydro and Magpie present programmers with their own data models—they control the persistence of updates and offer libraries of persistent collections as well as abstractions for users to implement their own data structures using the runtime's primitives. While this choice enables low-latency, in-memory compute with fine-grained control over the persistence of updates, it means that they cannot directly exchange data with external systems, instead relying on some ETL (extract, transform, load) layer. In the future both systems would likely benefit from supporting data formats such as Apache Arrow, which is fast becoming a de-facto format both for in-memory computing and, perhaps more critically, for data exchange. Support for external data formats would enable Hydro and Magpie to be deployed as subcomponents alongside already-running systems and their impact to be evaluated in an incremental fashion. </p> 
  <p>With the raised level of abstraction afforded to programmers—thanks to these systems' dataflow models—coupled with support for universal data formats, I anticipate new avenues for easily leveraging heterogeneous computing targets. As long as the infrastructure can mediate the exchange of data between distinct computing targets, potentially applying appropriate transformations, user programs will be free to mix and match on-CPU compute with accelerator offloading. Crucially, this kind of use case can be expected to illustrate the power of the IRs employed by Hydro and Magpie. The specific compute target requirements will need to become additional constraints that must be considered by the compiler stack or runtime when coming up with a system configuration or concrete execution plan, but the operations that involve accelerators and such can still be treated as another operator in a dataflow graph with semantics similar to those applied to CPU-oriented programs; therefore, user programs can be enabled to spill over to any kind of available accelerator without requiring any modification to the underlying high-level dataflow representations of these systems.</p> 
  <p>&nbsp;</p> 
  <h4>References</h4> 
  <p>1. Barroso, L. A., Clidaris, J., Holzle, U. 2013. <i>The Datacenter as a Computer: An Introduction to the Design of Warehouse-Scale Machines</i>, Second Edition. Morgan &amp; Claypool Publishers.</p> 
  <p>2. Bittman, D., et al. 2020. Twizzler: a data-centric OS for non-volatile memory. In <i>Proceedings of the Usenix Annual Technical Conference</i>; <a href="https://www.usenix.org/system/files/atc20-bittman.pdf">https://www.usenix.org/system/files/atc20-bittman.pdf</a>.</p> 
  <p>3. Chu, D. C. Y., et al. 2024. Optimizing distributed protocols with query rewrites. <i>Proceedings of the ACM on Management of Data 2(N1)</i>; <a href="https://dl.acm.org/doi/pdf/10.1145/3639257">https://dl.acm.org/doi/pdf/10.1145/3639257</a>.</p> 
  <p>4. DeCandia, G., et al. 2007. Dynamo: Amazon's highly available key-value store. <i>ACM SIGOPS Operating Systems Review 41(6)</i>, 205-220; <a href="https://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf">https://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf</a>.</p> 
  <p>5. Hellerstein, J. M., Alvaro, P. 2020. Keeping CALM: when distributed consistency is easy. <i>Communications of the ACM</i> <i>63(9)</i>, 72-81; <a href="https://dl.acm.org/doi/pdf/10.1145/3369736">https://dl.acm.org/doi/pdf/10.1145/3369736</a>.</p> 
  <p>6. Hellerstein, J. M., et al. 2023. Invited paper: initial steps toward a compiler for distributed programs. In the Fifth Workshop for Advanced Tools, Programming Languages, and Platforms for Implementing and Evaluating Algorithms for Distributed Systems; <a href="https://hydro.run/papers/joe-applied-2023.pdf">https://hydro.run/papers/joe-applied-2023.pdf</a>.</p> 
  <p>7. Hydro Project homepage; <a href="https://hydro.run/">https://hydro.run/</a>.</p> 
  <p>8. Seemakhupt, K. et al. 2023. A Cloud-Scale Characterization of Remote Procedure Calls. <a href="https://dl.acm.org/doi/10.1145/3600006.3613156">https://dl.acm.org/doi/10.1145/3600006.3613156</a></p> 
  <p>9. Temporal homepage; <a href="https://temporal.io/">https://temporal.io/</a>.</p> 
  <p>10. Zaharia, M., et al. 2012. Resilient distributed datasets: a fault-tolerant abstraction for in-memory cluster computing. <i>Proceedings of the Ninth Usenix Conference on Networked Systems Design and Implementation</i>; <a href="https://www.usenix.org/system/files/conference/nsdi12/nsdi12-final138.pdf">https://www.usenix.org/system/files/conference/nsdi12/nsdi12-final138.pdf</a>.</p> 
  <p>&nbsp;</p> 
  <p><b>Achilles Benetopoulos</b> is a Ph.D. student at UC Santa Cruz, working at the intersection of distributed systems, databases, and programming languages with Peter Alvaro, associate professor of computer science at UC Santa Cruz. Previously, he spent a few years working as a software engineer up and down the stack at a variety of companies.</p> 
  <p>Copyright © 2024 held by owner/author. Publication rights licensed to ACM.</p>  
 <script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'93509fa3edfad645',t:'MTc0NTQ0NTUyMC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script> 

	<p>
	
		<img class="floatLeft" src="img/q stamp_small.jpg" width="26" height="45" alt="acmqueue"><br><br>
	
	<em>Originally published in Queue vol. 22, no. 6</em>&#8212;
 	<br>
	Comment on this article in the <a href="http://portal.acm.org/citation.cfm?id=3712258">ACM Digital Library</a>
	
	</p>
	



<br />
<!--
<a href="https://twitter.com/share" class="twitter-share-button" data-via="ACMQueue">Tweet</a>
-->
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

<br />

<!--
<fb:like></fb:like>
-->

<br />

<div class="g-plusone" data-size="small" data-annotation="inline" data-width="120"></div>

<!-- these get hooked up to js events -->
<script type="text/javascript">
	addthis_pub             = 'acm';
	addthis_logo            = 'http://queue.acm.org/img/logo_queue_small.gif';
	addthis_logo_background = '#ffffff';
	addthis_logo_color      = '000000';
	addthis_brand           = 'ACM Queue';
	addthis_options         = 'reddit, slashdot, facebook, favorites, email, delicious, digg, technorati, blinklist, furl, myspace, google, live, more';
</script>

<!-- FB Like -->
<!--
<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "connect.facebook.net/en_US/all.js#xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

<div id="fb-root"></div>
-->

<!-- Place this tag after the last +1 button tag. -->

<!--
<script type="text/javascript">
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script>

<br />
<script src="https://connect.facebook.net/en_US/all.js#xfbml=1"></script>

<script>
FB.Event.subscribe('edge.create', function(targetUrl) {
  _gaq.push(['_trackSocial', 'facebook', 'like', targetUrl]);
});
</script>
-->



<hr noshade size=1 />




More related articles:

	  <p>
	  <span>Marc Brooker, Ankush Desai</span> - <a href="detail.cfm?id=3712057"><b>Systems Correctness Practices at AWS</b></a>
	  <br />
	  Building reliable and secure software requires a range of approaches to reason about systems correctness. Alongside industry-standard testing methods (such as unit and integration testing), AWS has adopted model checking, fuzzing, property-based testing, fault-injection testing, deterministic simulation, event-based simulation, and runtime validation of execution traces. Formal methods have been an important part of the development process - perhaps most importantly, formal specifications as test oracles that provide the correct answers for many of AWS's testing practices. Correctness testing and formal methods remain key areas of investment at AWS, accelerated by the excellent returns seen on investments in these areas already.
	  </p>
	  <br />

	  <p>
	  <span>David R. Morrison</span> - <a href="detail.cfm?id=3711677"><b>Simulation: An Underutilized Tool in Distributed Systems</b></a>
	  <br />
	  Simulation has a huge role to play in the advent of AI systems: We need an efficient, fast, and cost-effective way to train AI agents to operate in our infrastructure, and simulation absolutely provides that capability.
	  </p>
	  <br />

	  <p>
	  <span>Matt Fata, Philippe-Joseph Arida, Patrick Hahn, Betsy Beyer</span> - <a href="detail.cfm?id=3264508"><b>Corp to Cloud: Google&#8217;s Virtual Desktops</b></a>
	  <br />
	  Over one-fourth of Googlers use internal, data-center-hosted virtual desktops. This on-premises offering sits in the corporate network and allows users to develop code, access internal resources, and use GUI tools remotely from anywhere in the world. Among its most notable features, a virtual desktop instance can be sized according to the task at hand, has persistent user storage, and can be moved between corporate data centers to follow traveling Googlers. Until recently, our virtual desktops were hosted on commercially available hardware on Google&#8217;s corporate network using a homegrown open-source virtual cluster-management system called Ganeti. Today, this substantial and Google-critical workload runs on GCP (Google Compute Platform).
	  </p>
	  <br />

	  <p>
	  <span>Pat Helland</span> - <a href="detail.cfm?id=3025012"><b>Life Beyond Distributed Transactions</b></a>
	  <br />
	  This article explores and names some of the practical approaches used in the implementation of large-scale mission-critical applications in a world that rejects distributed transactions. Topics include the management of fine-grained pieces of application data that may be repartitioned over time as the application grows. Design patterns support sending messages between these repartitionable pieces of data.
	  </p>
	  <br />


<hr noshade size=1 />





<hr noshade size=1 />

	<p>
	<a href='#'><img src='https://queue.acm.org/img/logo_acm.gif' /></a>
	<br />
	&copy; ACM, Inc. All Rights Reserved.
	</p>

</div>



</body>
</html>