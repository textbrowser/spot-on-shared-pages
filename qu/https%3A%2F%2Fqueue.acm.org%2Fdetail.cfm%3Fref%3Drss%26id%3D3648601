<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>

<script src="/cdn-cgi/apps/head/nLYIPopMPWKseIlIthEH-UJkbT0.js"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-20JYM3ZFN0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-20JYM3ZFN0');
</script>
<title>Developer Ecosystems for Software Safety - ACM Queue</title>
<meta name="description" value />
<meta name="keywords" value="Security" />

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-P52H78L');</script>

<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="shortcut icon" href="favicon.ico" />
<script type="text/javascript" src="/js/jquery-1.2.6.min.js"></script>
<script type="text/javascript" src="/js/jquery.validate.min.js"></script>
<script type="text/javascript" src="/js/global.js"></script>

<link rel="alternate" type="application/rss+xml" title="All Queue Content RSS 2.0" href="/rss/feeds/queuecontent.xml" />
<link rel="alternate" type="application/rss+xml" title="Curmudgeon RSS 2.0" href="/rss/feeds/curmudgeon.xml" />
<link rel="alternate" type="application/rss+xml" title="Opinion RSS 2.0" href="/rss/feeds/opinion.xml" />
<link rel="alternate" type="application/rss+xml" title="Kode Vicious RSS 2.0" href="/rss/feeds/kodevicious.xml" />
<link rel="alternate" type="application/rss+xml" title="ACM TechNews RSS" href="https://www.infoinc.com/acm/TechNews.rss" />
<link rel="alternate" type="application/rss+xml" title="Washington Updates RSS" href="https://usacm.acm.org/weblog2/?feed=rss2" />
<link rel="alternate" type="application/rss+xml" title="RISKS Forum RSS" href="/rss/feeds/risksforum.xml" />
<link rel="alternate" type="application/rss+xml" title="AI RSS 2.0" href="/rss/feeds/ai.xml" />
<link rel="alternate" type="application/rss+xml" title="API Design RSS 2.0" href="/rss/feeds/apidesign.xml" />
<link rel="alternate" type="application/rss+xml" title="Bioscience RSS 2.0" href="/rss/feeds/bioscience.xml" />
<link rel="alternate" type="application/rss+xml" title="Blockchain RSS 2.0" href="/rss/feeds/blockchain.xml" />
<link rel="alternate" type="application/rss+xml" title="Business/Management RSS 2.0" href="/rss/feeds/business/management.xml" />
<link rel="alternate" type="application/rss+xml" title="Compliance RSS 2.0" href="/rss/feeds/compliance.xml" />
<link rel="alternate" type="application/rss+xml" title="Component Technologies RSS 2.0" href="/rss/feeds/componenttechnologies.xml" />
<link rel="alternate" type="application/rss+xml" title="Computer Architecture RSS 2.0" href="/rss/feeds/computerarchitecture.xml" />
<link rel="alternate" type="application/rss+xml" title="Concurrency RSS 2.0" href="/rss/feeds/concurrency.xml" />
<link rel="alternate" type="application/rss+xml" title="Cryptocurrency RSS 2.0" href="/rss/feeds/cryptocurrency.xml" />
<link rel="alternate" type="application/rss+xml" title="DSPs RSS 2.0" href="/rss/feeds/dsps.xml" />
<link rel="alternate" type="application/rss+xml" title="Data RSS 2.0" href="/rss/feeds/data.xml" />
<link rel="alternate" type="application/rss+xml" title="Databases RSS 2.0" href="/rss/feeds/databases.xml" />
<link rel="alternate" type="application/rss+xml" title="Debugging RSS 2.0" href="/rss/feeds/debugging.xml" />
<link rel="alternate" type="application/rss+xml" title="Development RSS 2.0" href="/rss/feeds/development.xml" />
<link rel="alternate" type="application/rss+xml" title="Distributed Computing RSS 2.0" href="/rss/feeds/distributedcomputing.xml" />
<link rel="alternate" type="application/rss+xml" title="Distributed Development RSS 2.0" href="/rss/feeds/distributeddevelopment.xml" />
<link rel="alternate" type="application/rss+xml" title="Education RSS 2.0" href="/rss/feeds/education.xml" />
<link rel="alternate" type="application/rss+xml" title="Email and IM RSS 2.0" href="/rss/feeds/emailandim.xml" />
<link rel="alternate" type="application/rss+xml" title="Embedded Systems RSS 2.0" href="/rss/feeds/embeddedsystems.xml" />
<link rel="alternate" type="application/rss+xml" title="Failure and Recovery RSS 2.0" href="/rss/feeds/failureandrecovery.xml" />
<link rel="alternate" type="application/rss+xml" title="File Systems and Storage RSS 2.0" href="/rss/feeds/filesystemsandstorage.xml" />
<link rel="alternate" type="application/rss+xml" title="Game Development RSS 2.0" href="/rss/feeds/gamedevelopment.xml" />
<link rel="alternate" type="application/rss+xml" title="Graphics RSS 2.0" href="/rss/feeds/graphics.xml" />
<link rel="alternate" type="application/rss+xml" title="HCI RSS 2.0" href="/rss/feeds/hci.xml" />
<link rel="alternate" type="application/rss+xml" title="Managing Megaservices RSS 2.0" href="/rss/feeds/managingmegaservices.xml" />
<link rel="alternate" type="application/rss+xml" title="Mobile Computing RSS 2.0" href="/rss/feeds/mobilecomputing.xml" />
<link rel="alternate" type="application/rss+xml" title="Networks RSS 2.0" href="/rss/feeds/networks.xml" />
<link rel="alternate" type="application/rss+xml" title="Object-Relational Mapping RSS 2.0" href="/rss/feeds/object-relationalmapping.xml" />
<link rel="alternate" type="application/rss+xml" title="Open Source RSS 2.0" href="/rss/feeds/opensource.xml" />
<link rel="alternate" type="application/rss+xml" title="Patching and Deployment RSS 2.0" href="/rss/feeds/patchinganddeployment.xml" />
<link rel="alternate" type="application/rss+xml" title="Performance RSS 2.0" href="/rss/feeds/performance.xml" />
<link rel="alternate" type="application/rss+xml" title="Power Management RSS 2.0" href="/rss/feeds/powermanagement.xml" />
<link rel="alternate" type="application/rss+xml" title="Privacy and Rights RSS 2.0" href="/rss/feeds/privacyandrights.xml" />
<link rel="alternate" type="application/rss+xml" title="Processors RSS 2.0" href="/rss/feeds/processors.xml" />
<link rel="alternate" type="application/rss+xml" title="Programming Languages RSS 2.0" href="/rss/feeds/programminglanguages.xml" />
<link rel="alternate" type="application/rss+xml" title="Purpose-built Systems RSS 2.0" href="/rss/feeds/purpose-builtsystems.xml" />
<link rel="alternate" type="application/rss+xml" title="Quality Assurance RSS 2.0" href="/rss/feeds/qualityassurance.xml" />
<link rel="alternate" type="application/rss+xml" title="RFID RSS 2.0" href="/rss/feeds/rfid.xml" />
<link rel="alternate" type="application/rss+xml" title="SIP RSS 2.0" href="/rss/feeds/sip.xml" />
<link rel="alternate" type="application/rss+xml" title="Search Engines RSS 2.0" href="/rss/feeds/searchengines.xml" />
<link rel="alternate" type="application/rss+xml" title="Security RSS 2.0" href="/rss/feeds/security.xml" />
<link rel="alternate" type="application/rss+xml" title="Semi-structured Data RSS 2.0" href="/rss/feeds/semi-structureddata.xml" />
<link rel="alternate" type="application/rss+xml" title="Social Computing RSS 2.0" href="/rss/feeds/socialcomputing.xml" />
<link rel="alternate" type="application/rss+xml" title="System Administration RSS 2.0" href="/rss/feeds/systemadministration.xml" />
<link rel="alternate" type="application/rss+xml" title="System Evolution RSS 2.0" href="/rss/feeds/systemevolution.xml" />
<link rel="alternate" type="application/rss+xml" title="Testing RSS 2.0" href="/rss/feeds/testing.xml" />
<link rel="alternate" type="application/rss+xml" title="Virtual Machines RSS 2.0" href="/rss/feeds/virtualmachines.xml" />
<link rel="alternate" type="application/rss+xml" title="Virtualization RSS 2.0" href="/rss/feeds/virtualization.xml" />
<link rel="alternate" type="application/rss+xml" title="Visualization RSS 2.0" href="/rss/feeds/visualization.xml" />
<link rel="alternate" type="application/rss+xml" title="VoIP RSS 2.0" href="/rss/feeds/voip.xml" />
<link rel="alternate" type="application/rss+xml" title="Web Development RSS 2.0" href="/rss/feeds/webdevelopment.xml" />
<link rel="alternate" type="application/rss+xml" title="Web Security RSS 2.0" href="/rss/feeds/websecurity.xml" />
<link rel="alternate" type="application/rss+xml" title="Web Services RSS 2.0" href="/rss/feeds/webservices.xml" />
<link rel="alternate" type="application/rss+xml" title="Workflow Systems RSS 2.0" href="/rss/feeds/workflowsystems.xml" />
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-6562869-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'stats.g.doubleclick.net/dc.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
<script type="text/javascript">
function plusone_vote( obj ) {
_gaq.push(['_trackEvent','plusone',obj.state]);
}
</script>
<style>
body {
	font-family: jaf-bernino-sans, 'Lucida Grande', 'Lucida Sans Unicode', 'Lucida Sans', Geneva, Verdana, sans-serif;
	color: #333;
	max-width: 100%;
}
div.container p {
	line-height: 1.65em;
}
h1 {
	font-size: 32px;
}
h3 {
	font-size: 18px;
}
h4 {
	font-size: 14px;
}

div.container {
	margin-left: auto;
	margin-right: auto;
}

div {
	margin: 64px;
//	max-width: 800px;
	position: relative;
}

@media only screen and (min-width: 1024px) {
	div {
		max-width: 800px;
	}
}

img {
    max-width: 100%;
    height: auto;
    width: auto\9; /* ie8 */
}
a {
	color: #009;
	text-decoration: none;
}
a:hover {
	text-decoration: underline;
}
hr {
	margin:64px;
}
label {
	font-size: 0.8em;
	color: #666;
}
input {
	color: #999;
}

/* NAVBAR */
.navbar {
//	position: fixed;
	background: #EEEEEE;
	top: -64px;
	z-index: 10000;
	width: 100%;
	clear: both;
	padding: 0px;
	margin: 0px;
	padding-top: 10px;
	padding-left: 10px;
	padding-right: 10px;
}

/*  SECTIONS  */
.section {
	clear: both;
	padding: 0px;
	margin: 0px;
}

/*  COLUMN SETUP  */
.col {
	display: block;
	float:left;
	margin: 1% 0 1% 1.6%;
}
.col:first-child { margin-left: 0; }


/*  GROUPING  */
.group:before,
.group:after {
	content:"";
	display:table;
}
.group:after {
	clear:both;
}
.group {
    zoom:1; /* For IE 6/7 */
}

/*  GRID OF THREE  */
.span_3_of_3 {
	width: 100%;
}
.span_2_of_3 {
	width: 66.1%;
}
.span_1_of_3 {
	width: 32.2%;
}

/*  GO FULL WIDTH AT LESS THAN 480 PIXELS */

@media only screen and (max-width: 480px) {
	.col {
		margin: 1% 0 1% 0%;
	}
}

@media only screen and (max-width: 480px) {
	.span_3_of_3 {
		width: 100%;
	}
	.span_2_of_3 {
		width: 100%;
	}
	.span_1_of_3 {
		width: 100%;
	}
}

.span_2_of_2 {
	width: 100%;
}

.span_1_of_2 {
	width: 49.2%;
}

/*  GO FULL WIDTH AT LESS THAN 480 PIXELS */

@media only screen and (max-width: 480px) {
	.span_2_of_2 {
		width: 100%;
	}
	.span_1_of_2 {
		width: 100%;
	}
}
</style>
<style>
body {
	font-size: 19px;
}
#form-search > .st-default-search-input {
	width: 170px;
  display: inline-block;
  height: 16px;
  padding: 7px 11px 7px 28px;
  border: 1px solid #bbb;
  border: 1px solid rgba(0,0,0,0.25);
  font-weight: 400;
  color: #3B454F;
  font-size: 14px;
  line-height: 16px;
  -webkit-box-sizing: content-box;
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-box-shadow: none;
  -moz-box-shadow: none;
  box-shadow: none;
  font-family: system, -apple-system, BlinkMacSystemFont, "Helvetica Neue", "Lucida Grande", sans-serif;
}


blockquote
{
    color: #666;
    font-size: 1.1em;
    background: none;
    border-left: .2rem solid #d3d3d3;

    display: block;
    padding: 20px 20px 10px 45px;
    margin: 20px 0;
    font-style: italic;

    margin-block-start: 1em;
    margin-block-end: 1em;
    margin-inline-start: 40px;
    margin-inline-end: 40px;

	font-family: Georgia, Palatino, "Palatino Linotype", Times, "Times New Roman", serif;
}

.ldq {
	display: block;
    padding-left: 10px;
    content: "\201C";
    font-size: 60px;
    position: relative;
    left: -50px;
    top: 0;
    height: 0;
    color: #7a7a7a;
}
code {
//	font-size:1.25em;
}
a {overflow-wrap: break-word;}
</style>
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<div class="container">
<div class="navbar">
<form id="form-search" name="searchform" onsubmit="return false;" style="float:right;">
<input type="text" class="st-default-search-input">
<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','UyYECD1kdsPnbHJtPyzG','2.0.0');
</script>
<br/>
<a href="issuedetail.cfm?issue=3665607" style="width:150px;font-size:0.7em;">Current Issue</a> &nbsp; <a href="pastissues.cfm" style="width:150px;font-size:0.7em;">Past Issues</a> &nbsp; <a href="topics.cfm" style="width:150px;font-size:0.7em;">Topics</a>
</form>
<a href="/"><img src="https://queue.acm.org/img/acmqueue_logo.gif" /></a>
</div>

<br/>
<label>February 29, 2024<br/><b><a class="descriptor" href="issuedetail.cfm?issue=3650211">Volume 22, issue 1 </a></b></label>
<p>

&nbsp;
<a href="https://portal.acm.org/citation.cfm?id=3648601">
<img src="img/icon_pdf.png" alt="Download PDF version of this article" />
PDF
</a>
</p>
<h1 class="hidetitle">Developer Ecosystems for Software Safety</h1>
<h2>Continuous assurance at scale</h2>
<h3>Christoph Kern</h3>
<p>How to design and implement information systems so that they are safe and secure is a complex topic. Both high-level design principles and implementation guidance for software safety and security are well established and broadly accepted. For example, Jerome Saltzer and Michael Schroeder's seminal overview of principles of secure design was published almost 50 years ago,<sup>11</sup> and various community and governmental bodies have published comprehensive best practices about how to avoid common software weaknesses—for example, <a href="https://cwe.mitre.org/">CWE</a> (Common Weakness Enumeration) and <a href="https://cheatsheetseries.owasp.org/">OWASP</a> (Open Worldwide Application Security Project) <a href="https://cheatsheetseries.owasp.org/">Cheat Sheet Series</a>.</p>
<p>Despite these efforts, common types of software defects prevail, and many occupy top ranks of "worst vulnerabilities" lists such as the <a href="https://owasp.org/Top10">OWASP Top 10</a><sup>10</sup> or the CWE Top 25 Most Dangerous Software Weaknesses<sup>4</sup> for years if not decades.</p>
<p>Based on work at Google over the past decade on managing the risk of software defects in its wide-ranging portfolio of applications and services, the members of Google's security engineering team developed a theory about the reason for the prevalence of defects: It's simply too difficult for real-world development and operations teams to comprehensively and consistently apply the available guidance, which results in a problematic rate of new defects. Commonly used approaches to find and fix implementation defects after the fact can help (e.g., code review, testing, scanning, or static and dynamic analysis such as fuzzing), but in practice they find only a fraction of these defects. Design-level defects are difficult or impractical to remediate after the fact. This leaves a problematic residual rate of defects in production systems.</p>
<p>We came to the conclusion that the rate at which common types of defects are introduced during design, development, and deployment is systemic—it arises from the design and structure of the <i>developer ecosystem</i>, which means the end-to-end collection of systems, tooling, and processes in which developers design, implement, and deploy software. This includes programming languages, software libraries, application frameworks, source repositories, build and deployment tooling, the production platform and its configuration surfaces, and so forth.</p>
<p>In short, the safety and security posture of a software application or service is substantially an emergent property of the developer ecosystem that produced it. (A safe system mitigates risks of relevant harms and adverse outcomes for its users and stakeholders. A secure system does so even in an adversarial context. Security is about defending against active threats, beyond accidents or mistakes.<sup>17</sup>)</p>
<p>It follows that to truly improve the situation, focusing on design and implementation guidance in the context of individual applications comes too late in the process. Instead, development and operations teams need to shift-left even further and incorporate software safety and security considerations in the design of developer ecosystems. (While this article focuses on safety and security, many of the principles and practices discussed here transfer to reliability engineering, and it is often helpful to consider security and reliability together.<sup>1</sup>)</p>
<p>This article argues, based on experience at Google, that focusing on developer ecosystems is both practical and effective, and can achieve a drastic reduction in the rate of common classes of defects across hundreds of applications being developed by thousands of developers. </p>
<p>There are two key aspects to this approach for achieving assurance at scale.</p>
<p>• <b>Preventing bugs through Safe Coding.</b> First, many common implementation-level security defects, such as injection or memory safety vulnerabilities, are difficult to avoid entirely in large and complex codebases, even for experienced developers who thoroughly understand the nature of the vulnerability in principle. When a codebase has many instances of coding patterns that are <i>potentially vulnerable</i>—placing the onus on developers to be careful every single time—defects will happen.</p>
<p>Thus, the only approach that can significantly reduce the rate of defects is for the developer ecosystem to take responsibility for preventing vulnerabilities by presenting a <i>Safe Coding</i> environment with respect to the class of defects in question.</p>
<p>In this model, the developer ecosystem is responsible for ensuring that every version of the system satisfies <i>safety and security invariants</i>—that is, properties that the system is expected to ensure at all times, even when operating in an adversarial external environment. In many cases, safety invariants can be expressed through language, API and application framework design, or through domain-specific code and configuration conformance checks.</p>
<p>At Google this approach was successfully applied to several classes of previously intractable defects, including XSS (cross-site scripting) and SQL injection, which occupy positions 2 and 3 in the CWE Stubborn Weaknesses ranking.<sup>3</sup> Today, many Google user-facing applications are developed in a Safe Coding ecosystem and exhibit close to zero residual rates of relevant defects.</p>
<p>• <b>Secure design for application archetypes</b>. Second, a substantial number of applications and services can be grouped into a much smaller set of common archetypes. For example, the high-level architectural shape of many user-facing services can be characterized as "a web app with microservices back ends and a SQL database" or "a client-side mobile app that relies on a web services API."</p>
<p>It turns out that many aspects of an individual application's safety and security risk model are common to all applications in the archetype: Every web app must worry about XSS vulnerabilities, and every RPC (remote procedure call) back end must authenticate and authorize its callers.</p>
<p>This observation can be leveraged by designing developer ecosystems tuned to the given archetype, and by structuring ecosystem components (such as libraries, application frameworks, and production platforms) to address common aspects of the archetype's risk model template. Developing in such an environment reduces effort, cognitive load, and opportunities for mistakes and omissions for individual product teams—and mitigates risks across the entire ecosystem.</p>
<p>In short, the key to safety and assurance at scale is to design developer ecosystems that ensure secure design best practices and prevent relevant classes of vulnerabilities across all applications of an archetype. This also increases development velocity, because application developers don't have to think about vulnerabilities while focused on functionality.</p>
<p>&nbsp;</p>
<h3>Safe Coding</h3>
<p>Many common classes of security vulnerabilities, such as memory corruption, SQL injection, and XSS, arise when a developer makes an incorrect assumption about the possible behaviors of a large and complex software system (especially when faced with adversarial inputs) while adding or modifying code whose correctness and safety depends on those assumptions. Comprehensive awareness of all relevant assumptions is particularly difficult to achieve when large teams maintain software over long periods of time.</p>
<p>Past attempts to mitigate these types of vulnerabilities focused on developer education along with tools and processes to discover and fix defects later in the development cycle. Neither approach proved effective, and these classes of defects continue to occur in "top vulnerability" rankings and feature prominently in the Stubborn Weaknesses in the CWE Top 25.<sup>3</sup></p>
<p>First, developer education is insufficient to reduce defect rates in this context. Intuition tells us that to avoid introducing a defect, developers need to practice constant vigilance and awareness of subtle secure-coding guidelines. In many cases, this requires reasoning about complex assumptions and preconditions, often in relation to other, conceptually faraway code in a large, complex codebase. When a program contains hundreds or thousands of coding patterns that could harbor a potential defect, it is difficult to get this right every single time. Even experienced developers who thoroughly understand these classes of defects and their technical underpinnings sometimes make a mistake and accidentally introduce a vulnerability.</p>
<p>Second, approaches to after-the-fact discovery of defects, such as static or dynamic analysis (including fuzzing), are inherently incomplete when applied to large systems with large, complex state spaces. In many cases, these techniques are computationally intensive and too slow to apply after a code change is written but before it is committed. When defect discovery happens post-commit, it cannot reduce the rate at which new defects are introduced into the source repository.</p>
<p>When software safety is framed as an emergent property of how it is developed, the potential of implementation security defects should be viewed as a design flaw of the development environment: The potential for defects is a hazard that arises during development, and it's the responsibility of the development environment to mitigate this hazard. (In the context of information systems, a hazard is the potential for a user or other stakeholder to experience harm, or more generally, some adverse outcome. Here, the adverse outcome is the introduction of a vulnerability, which in turn results in a downstream risk of harm to the eventual software user. This specifically does not mean attacks on the developers themselves, such as via malware embedded in a developer tool.)</p>
<p>At Google this approach is called <i>Safe Coding</i>, because it's centered on structuring development environments that are safe with respect to the accidental introduction of security defects during application design and development.</p>
<p>In the following sections, this article illustrates Safe Coding principles by showing how they apply to several classes of common software safety and security defects, then briefly discusses the cost effectiveness of this approach.</p>
<p>&nbsp;</p>
<h4>Memory safety</h4>
<p>Some of the most common and impactful classes of security vulnerabilities arise from memory safety defects, including code that accesses memory outside the bounds of valid, allocated objects, as well as temporal memory safety violations such as accessing memory that was already deallocated ("<i>use-after-free</i>"). </p>
<p>Memory safety issues rank 1, 4, 7, and 12 in the 2023 CWE Top 25.<sup>4</sup> Several organizations have reported that memory safety issues cause a substantial majority of severe vulnerabilities in large C/C++ codebases, including Chrome (<a href="https://www.chromium.org/Home/chromium-security/memory-safety">bit.ly/482j6Ms</a>), Android (<a href="https://android-developers.googleblog.com/2020/02/detecting-memory-corruption-bugs-with-hwasan.html">bit.ly/4a6DYnC</a>), Project Zero (<a href="https://googleprojectzero.github.io/0days-in-the-wild/">bit.ly/416oXxS</a>), and Microsoft (<a href="https://msrc.microsoft.com/blog/2019/07/a-proactive-approach-to-more-secure-code/">bit.ly/3RpRMCj</a>).</p>
<p>Guidance for developers in memory-unsafe languages such as C and C++ is, essentially, to be careful: For example, the section on memory management of the SEI CERT C Coding Standard<sup>12</sup> stipulates rules like, "MEM30-C: Do not access freed memory" (<a href="https://wiki.sei.cmu.edu/confluence/display/c/MEM30-C.+Do+not+access+freed+memory">bit.ly/3uSMBSk</a>).</p>
<p>While this guidance is technically correct, it's difficult to apply comprehensively and consistently in large, complex codebases. For example, consider a scenario where a software developer is making a change to a large C++ codebase, maintained by a team of dozens of developers. The change intends to fix a memory leak that occurs because some heap-allocated objects aren't deallocated under certain conditions. The developer adds deallocation statements based on the implicit assumption that the objects will no longer be dereferenced. Unfortunately, this assumption turns out to be incorrect, because there is code in another part of the program that runs later and still dereferences pointers to this object.</p>
<p>This example illustrates why the coding rule can be difficult to adhere to in practice: Attempting to fix a memory leak, the developer changes existing code by adding a statement to free memory that they assume is no longer used. After the change, code <i>elsewhere</i> in the program—code that the developer didn't modify, and perhaps wasn't even aware of—now violates the <i>do not access freed memory</i> rule, resulting in a memory safety bug.</p>
<p>The part of the program that the developer modified, and the separate part of the program that contains a new bug after the change, are implicitly connected through assumptions about the allocation state of the object in question. These kinds of implicit assumptions about the state of a large and complex program are easy to miss for a developer who is familiar with only parts of the whole, which is common for large programs worked on by teams of many developers.</p>
<p>In some cases, it's possible to design and structure a program to make such assumptions more apparent—for example, through the use of pointer types that explicitly encode an ownership and lifetime discipline (such as <code>unique_ptr</code> and <code>shared_ptr</code> in C++). These kinds of considerations are not always applied comprehensively and consistently, however, and memory safety vulnerabilities are quite common in C++ as well as C.</p>
<p>When the risk of classes of defects is viewed as emerging from the design of the developer ecosystem, it follows that the prevalence of memory safety defects emerges from the design of the programming language and surrounding tooling. Simply put, when millions of lines of code are written in a programming language that places the onus <i>on developers</i> to ensure that every dereference of a pointer is valid and in bounds, there are going to be defects.</p>
<p>In contrast, <i>memory-safe languages</i> remove this responsibility from developers and ensure memory safety invariants through the design of the language and its runtime. For example, in garbage-collected languages such as Java and Go, developers do not write explicit statements to deallocate memory; instead the language and its runtime take this responsibility and deallocate memory only when an object is no longer referenced. Alternatively, in Rust, object ownership and lifetime are expressed as native concepts in the language's type system. This allows rigorous verification of memory-safety invariants at compile time, avoiding the runtime overhead of garbage collection.</p>
<p>&nbsp;</p>
<h4>Code injection vulnerabilities</h4>
<p>Injection vulnerabilities arise when strings derived from untrusted inputs are passed to an API—referred to as an <i>injection sink</i> in this context—that interprets the string <i>as code</i> in some domain-specific language, such as SQL or HTML. In this setting, it's crucial to ensure a <i>rigorous separation</i> between the trusted code and the untrusted data: If untrusted, potentially attacker-provided <i>data</i> can be unintentionally interpreted and evaluated as <i>code,</i> then the attacker can exploit the trust placed on the execution environment and execute actions with its (elevated) privileges.</p>
<p>For example, XSS vulnerabilities arise when untrusted inputs are incorporated into HTML or passed to certain web browser APIs without context-appropriate escaping, sanitization, or validation. This can allow attackers to cause JavaScript code under their control to execute in the context of a user's web application session, which would then allow the attacker to exfiltrate or modify user data. Similarly, SQL injection vulnerabilities can arise when untrusted input strings are incorporated into a SQL database query; in this case an attacker could alter the intended function of the query, causing it to return or modify data that should not be accessible to the attacker. Both types of vulnerabilities are quite common and impactful, and occupy ranks 2 and 3, respectively, of the 2023 CWE Top 25.<sup>4</sup></p>
<p>In the past, mitigation of these classes of vulnerabilities focused on teaching developers rather complex rules (see, for example, OWASP's XSS Prevention Cheat Sheet at <a href="https://dl.acm.org/about:blank">bit.ly/47I90At</a>) for treating potentially untrusted data before it is incorporated into HTML markup or SQL queries. This doesn't work well in practice: The rules are complicated, and it's often difficult to keep track of which rules were applied to a given string. For example, when a string that originated in a system's back-end storage layer is incorporated into HTML markup in a web application front end, it can be hard for the front-end developer to tell whether that string was sanitized at the time it was stored. Large web applications can have hundreds of code sites that pass data to JavaScript injection sinks, and incorrect or omitted sanitization or escaping in a single instance can result in a vulnerability that compromises the entire application.</p>
<p>Again, the prevalence of these classes of defects can be viewed as an emergent property of the design of the developer ecosystem rather than a failure of developers to apply the correct one of a set of obscure rules, a thousand times over. In this framing, the root cause for these classes of defects is in the design of APIs that represent potential injection sinks: Typically, these APIs accept statements and expressions in domain-specific languages such as HTML, JavaScript, CSS, or SQL, represented as values of a general-purpose <code>String</code> type. In this API design it is the developer's responsibility to ensure that untrusted values incorporated into these strings are sanitized or escaped according to the domain-specific language's rules. This is brittle and prone to mistakes that can result in injection vulnerabilities.</p>
<p>Based on this view of the problem's root cause, these classes of vulnerabilities can be addressed by introducing higher-level abstractions that <i>take responsibility</i> for separating trusted code or markup and untrusted data. For example, there are <i>strict contextually auto-escaping template systems</i><sup>6</sup> for HTML to ensure that untrusted inputs are appropriately sanitized or escaped before being interpolated. Similarly, we provide builder APIs to construct SQL statements from trustworthy statement fragments.</p>
<p>To ensure that <i>all</i> statements and expressions that are passed to an injection sink API are constructed using these safe abstractions, the design of sink APIs has been changed to require a <i>domain-specific vocabulary type</i> rather than plain strings. The vocabulary type's type contract captures the safety precondition of the injection sink API. In turn, values of these types are produced only by corresponding safe abstractions, which ensures that they adhere to their contract.</p>
<p>For example, the SQL query APIs by which internal Google developers interact with the Spanner database<sup>2</sup> expect values of type <code>TrustedSqlString</code> and do not accept queries represented as simple <code>Strings</code>. This type represents strings that are safe to use as a query without risk of SQL injection vulnerabilities. Values of type <code>TrustedSqlString</code> can be created only by using builder APIs and factory functions that ensure this type contract. These APIs allow queries to be constructed from query snippets of known, trustworthy provenance such as trusted configuration files or literal strings that are part of the program itself. Arbitrary, potentially untrusted strings cannot be incorporated into a SQL statement—the <code>TrustedSqlString</code> builder API simply has no <code>append</code> method that accepts arbitrary <code>String</code>-typed values. This results in a typing discipline that enforces the (otherwise ad-hoc) secure-coding guideline to assemble SQL queries from trusted strings and to supply dynamic parameters via query parameter binding (see, for example, OWASP's guidance at bit.ly/3LUPyrk).</p>
<p>Similarly, XSS risk is addressed by defining a set of vocabulary types to represent strings that are safe for web platform injection sinks. For example, values of type <code>SafeHtml</code> can be safely returned as <code>text/html</code> web server responses, interpolated into an HTML document in an "HTML tag content" context, or assigned to the <code>.innerHTML</code> DOM property in browser-side JavaScript. These types and their associated safe builder APIs have been implemented in Google production languages. (For example, open-source implementations for TypeScript and Go are available at <a href="https://github.com/google/safevalues">https://github.com/google/safevalues</a> and <a href="https://github.com/google/safehtml">https://github.com/google/safehtml</a>, respectively. )</p>
<p>In addition, we developed a W3C standards proposal, <i>Trusted Types</i>, to integrate corresponding types natively into the web platform.<sup>7</sup></p>
<p>Similar to the type-constrained SQL query API, we augmented server-side application frameworks, HTML templating systems, server-side response APIs, and browser-side application frameworks and templating systems to constrain API parameters to the corresponding type that, by its contract, is safe to use in the given API's context.<sup>15</sup></p>
<p>Constraining potentially unsafe usage of injection sinks through vocabulary types and safe abstractions achieves a high degree of confidence that <i>any program accepted by compile- and runtime type checks</i> is free of injection vulnerabilities—if it compiles, it's secure! (See references 6 and 14 and reference 1, chapter 12, "Writing Code," for more details on preventing injection vulnerabilities through Safe Coding.)</p>
<p>At Google we found that Safe Coding is the only approach that can substantially reduce the incidence of injection vulnerabilities, especially at the scale of Google's codebase. For example, 10 years ago, we tended to encounter tens of XSS vulnerabilities per year for each large, complex web application like Gmail. Since then, Safe Coding practices and safe-types discipline, including browser-side <i>Trusted Types</i> enforcement, have been incorporated into internal web application frameworks that are widely used for new and existing web applications (bit.ly/3uLHFip). </p>
<p>Today, the residual incidence of XSS vulnerabilities across <i>all</i> frameworks-based applications is in the low single digits (some residual XSS risk arises from, for example, pre-existing application components that have not yet been refactored to conform to the safe-types discipline and are exempted from enforcement on a "legacy" basis). Some large services, such as the Google Photos web front end, have not had <i>any</i> XSS vulnerabilities reported over their entire lifetimes. Similarly, SQL injection is essentially a nonissue in the Google internal codebase. In contrast, XSS and SQL injection occupy spots 2 and 3 in the CWE project's 2023 Stubborn Weaknesses ranking.<sup>3</sup></p>
<p>Safe Coding prevents injection vulnerabilities at modest initial and ongoing costs:<sup>14</sup></p>
<p>• We rely primarily on judicious API design that takes advantage of language-native type systems, augmented with inexpensive code conformance checks where necessary—for example, the <code>CompileTimeConstant</code> check implemented as part of the Error Prone framework (<a href="https://errorprone.info/bugpattern/CompileTimeConstant">bit.ly/3RsSVIf</a>). This results in minimal additional resource demands at application runtime and on build systems and CI/CD (continuous integration/continuous delivery) infrastructure.</p>
<p>• Beyond initial efforts to develop safe APIs and frameworks, ongoing maintenance and support costs are modest. For example, at Google a small team of security engineers maintains Safe Coding libraries, framework components, and code conformance checks for secure web application development, and provides user support for a population of many thousands of web application developers at Google.</p>
<p>&nbsp;</p>
<h3>Safe Deployment</h3>
<p>Production deployments of services, and the underlying infrastructure, can quickly get complicated, even in organizations much smaller than Google.</p>
<p>Consider an SRE (site reliability engineer) who is tasked with setting up a new production environment. The production environment includes devices (routers, firewalls, load balancers, database servers, applications servers, and more) made by several vendors, each with its own configuration UIs and config languages. The engineer has a playbook document that outlines the changes to be made, but setting up the environment is essentially a manual process.</p>
<p>This is error-prone—the engineer might accidentally make a change to the wrong device (perhaps caused by a simple typo in a command-line argument) or make a change that has unintended consequences, because of subtle discrepancies in configuration semantics across different vendor devices.</p>
<p>This could result in a misconfiguration with security impact, such as exposing an internal network service to the public Internet, a missing or overbroad access-control list, or an outage in an unrelated service hosted in the same production environment.</p>
<p>When this happens, it's tempting to say "They should have been more careful" but it's ultimately an unreasonable expectation that any human has a perfectly accurate mental model of a production environment consisting of hundreds of devices with thousands of config settings expressed in several different configuration models.</p>
<p>Instead, just as for common coding mishaps, the potential for deployment mishaps should be treated as a hazard, and it should be the deployment environment's responsibility to protect engineers from encountering these hazards.<sup>8</sup></p>
<p>Safety from deployment hazards can be incorporated into deployment environments in several ways. Examples of practices found useful at Google include cloud platforms, config-as-code, and Zero Touch Prod and Safe Proxies.</p>
<p>&nbsp;</p>
<h4>Cloud platforms</h4>
<p>When deployment environments are based on "bare-metal" servers and network devices, engineers are exposed to the full complexity and nonuniformity of their configuration surfaces. In contrast, cloud platforms provide a higher-level abstraction and a consistent vocabulary of configuration points, and they expose common functionality (such as databases) as managed services. This reduces cognitive load caused by differences between configuration surfaces of different types of network devices and the need to manage lower-level aspects of servers that host higher-level services such as databases.</p>
<p>Cloud platforms can integrate enforcement of security invariants into their control planes. For example, Google's production environment<sup>13</sup> enforces binary authorization policies (<a href="https://cloud.google.com/docs/security/binary-authorization-for-borg">https://cloud.google.com/docs/security/binary-authorization-for-borg</a>) to govern whether a deployment package can run with the privileges of a given role. For sensitive roles, these policies typically require that the binary package is accompanied by a provenance attestation (<a href="https://slsa.dev/provenance/v1">https://slsa.dev/provenance/v1</a>) that it was built by an authorized, trusted build system from code in a trusted source repository where changes are reviewed under the two-person principle. This mechanism ensures, on an ongoing basis, the invariant that only explicitly authorized code can exercise the privileges of a given production role.</p>
<p>&nbsp;</p>
<h4>Config-as-code</h4>
<p>Making changes to production systems directly—through configuration UIs (user interfaces) or CLIs (command-line interfaces)—is risky: Changes are actuated immediately, including any mistakes.</p>
<p>A safer approach is to capture the entire configuration in machine-readable config files stored in a versioned repository, and to automatically actuate changes to the production environment based on this configuration. This pattern is often called config-as-code (or sometimes GitOps), because authoritative configuration is maintained in a source repository, just like an application's source code.</p>
<p>Maintaining configuration in this fashion allows the introduction of safeguards against configuration mistakes:</p>
<p>• The configuration repository can be set up to require two-person review. This gives a second engineer the opportunity to catch mistakes.</p>
<p>• Changes to the configuration can be guarded by conformance checks that execute pre-submit and/or before a configuration change is actuated. Similar to conformance checks on source code discussed earlier, such conformance checks can ensure safety and correctness invariants on the configuration on an ongoing basis. For example, a conformance check can ensure that the authorization policies of back-end RPC services adhere to common guidelines and best practices.</p>
<p>• Common types of changes can be automated through tools that generate sections of configuration. The configuration for a new service instance can be generated automatically based on a template, reducing the opportunity for mistakes caused by typos.</p>
<p>&nbsp;</p>
<h4>Zero Touch Prod and safe proxies</h4>
<p>Zero Touch Prod is a set of principles and tools to ensure that every change to a production environment must be made by trusted automation (not directly by a human), prevalidated by trusted software, or made through an audited break-glass mechanism.<sup>5</sup></p>
<p>Conformance checks imposed on config-as-code are one way of adhering to this principle. It can be challenging, however, to accommodate all actions in a production environment through config-as-code, especially those needed when responding to an incident.</p>
<p><i>Safe Proxies</i> are trusted systems that are interposed between human engineers and a production environment (see chapter 3 of reference 1). The safe proxy mediates all interactions with the production environment and can, for example:</p>
<p>• Validate the safety of requested actions.</p>
<p>• Impose security policy such as mandatory auditing and mandatory multiparty authorization.</p>
<p>• Rate-limit potentially destructive actions.</p>
<p>In addition to enhancing safety with respect to human error (such as honest mistakes), these techniques also provide an effective control against insider risk and external compromise of privileged operators. When in place, these measures remove engineers' ambient privileges to unilaterally execute powerful and sensitive actions in the production environment. Instead, changes and actions in production are guarded by two-person review, automated validation, and mandatory auditing.</p>
<p>&nbsp;</p>
<h3>Scaling Secure Design Across Application Archetypes</h3>
<p>The previous sections discussed how to achieve substantial leverage over implementation bugs and deployment defects, by treating them not as individual defects but rather as an entire class of defects to be addressed through development and deployment ecosystem design (programming languages, application frameworks, build systems, cloud platforms, and so on).</p>
<p>Similar thinking can even be applied to defects that, in isolation, are true design flaws rather than implementation bugs—that is, defects that arise from a fundamental choice about the shape or architecture of a product or service.</p>
<p>A key observation is that many types of potential architectural and design flaws, and the safety and security considerations and practices to avoid them, apply to <i>all applications of a software-architectural archetype</i>. Examples of such archetypes might include:</p>
<p>• A system consisting of an end-user-facing web application front end communicating with back-end microservices through RPCs, which in turn rely on a SQL database for persistence.</p>
<p>• A mobile application backed by a service API; the service API front end in turn makes RPCs to back-end microservices.</p>
<p>While many threats and secure-design considerations are indeed specific to a given application (e.g., a banking app is inherently different from a photo editor) typically, a substantial degree of commonality exists in the threat models across the entire class of applications of a given archetype.</p>
<p>For example, the safety and security design of (almost) any application that falls into either of these archetypes must consider areas such as:</p>
<p>• Protecting the confidentiality and integrity of network and RPC traffic over the public Internet and internal networks.</p>
<p>• Ensuring that all external client-server requests and internal RPC requests are appropriately authenticated and authorized, governed by an explicit, intentional policy (although the details of the policy itself are usually specific to the application and its features).</p>
<p>• Ensuring that the confidentiality and integrity of user/customer data is appropriately protected in conformance with the service provider's policies (for example, through appropriate cryptographic schemes).</p>
<p>• Ensuring that user data is deleted according to the service provider's policies (such as when requested by a user or when a user leaves the service).</p>
<p>• And many more.</p>
<p>Google has hundreds of web and mobile applications and external-facing API endpoints, and thousands of microservice back ends and internal RPC endpoints, but even organizations much smaller than Google usually have at least several. It's undesirable for each team responsible for one of these services to develop a comprehensive threat model from scratch and to design appropriate mitigations for each one. Taking such a decentralized approach results in not only duplication of work, but also inferior outcomes: Threat modeling and secure design require expertise that is often not available in product development teams; while an organization's security experts can help through consulting, their bandwidth is typically limited.</p>
<p>At Google we take advantage of common threat model aspects and secure design considerations by building frameworks and platforms that inform, govern, and constrain important aspects of the architecture and design (both in terms of code and mapping to production resources) of applications and services built on the framework.<sup>9</sup> These applications inherit security (also privacy and reliability) best practices designed and built into the framework, usually through collaboration between domain experts (security engineers, SREs) and framework engineers.</p>
<p>Many design choices (Which secure transport protocol should I use? How should I authenticate and authorize requests? How do I encrypt data at rest?) are incorporated in the design of the framework, and application developers are relieved from making these decisions—and from potentially making a suboptimal choice.</p>
<p>This approach reduces the risk of design-level security defects and gives leverage to scarce expert bandwidth—experts can focus their attention on the design and implementation of frameworks and platforms, while having an impact on a large number of development projects that rely on that framework.</p>
<p>Furthermore, after frameworks are widely adopted as a platform for application development, <i>future</i> security improvements and mitigations for novel attacks and defect classes can often be deployed swiftly, scalably, and efficiently, taking advantage of the well-defined structure of frameworks-based applications. For example, security and web frameworks teams at Google routinely roll out new security features and mitigations at scale to existing frameworks-based applications, often without any need for involvement or time investment by the teams that maintain individual applications. (See the blog post <i>A Recipe for Scaling Security,</i> at <a href="https://bughunters.google.com/blog/5896512897417216/a-recipe-for-scaling-security">bit.ly/3u6C71R</a>, for more details.)</p>
<p>&nbsp;</p>
<h3>Continuous Assurance at Scale</h3>
<p>At Google we sometimes say, "Software engineering is programming integrated over time," to recognize the vast difference between one or a few people writing a few-thousand-line program in days or weeks, versus hundreds of teams of hundreds of developers jointly working, over years or even decades, on a codebase of several hundred million lines of code.<sup>16</sup></p>
<p>This distinction matters when it comes to ensuring security invariants for software products and the degree of confidence in the product adhering to these invariants. For a small, self-contained program written by a small group over a short period of time, developers are less likely to make mistaken assumptions that lead to defects, and it is indeed feasible for an expert to read and understand the entire codebase and perform a high-confidence security assessment.</p>
<p>Once a service's design, codebase, and production footprint get larger and more complex, this no longer works: The risk of defects caused by mistaken assumptions (or plain mistakes and forgetfulness) increases. It becomes infeasible for an expert, or even a group of experts, to fully and deeply understand the entire artifact, resulting in limits on high-confidence security assessments. </p>
<p>If the experts need to read and understand most of a codebase of many hundreds of thousands of lines of code, it's likely they will miss something, or make a mistake in their assessment. (Tool support such as static analyzers can sometimes help; however, these typically need to accept some degree of imprecision to scale to large codebases, and hence can also "miss things.") </p>
<p>Furthermore, security assessments by human experts apply to the specific version under review and are difficult to scale to every release of software that is under active ongoing feature development.</p>
<p>As explained in this article, Google addresses this challenge by designing a developer ecosystem to ensure that all services developed and deployed in this environment have the desired properties. We achieve high levels of assurance by applying the principle of "Design for Understandability" (chapter 6 in reference 1): Key developer ecosystem components are designed to ensure the property for <i>any arbitrary</i> application, assuming only that application code is well-typed, passes conformance checks, and satisfies basic assumptions. (Code written and reviewed under the two-person principle is generally assumed not to deliberately subvert security invariants—for example, through use of reflection or unsafe casts.) </p>
<p>This allows us to have confidence that the property holds for <i>all applications</i>, based solely on understanding key developer ecosystem components, and without having to consider or understand application-specific code. There is still a residual risk of defects, but it is confined within those key components. These tend to be stable, and domain experts can thoroughly scrutinize them for potential defects.</p>
<p>In light of the framing as <i>programming over time</i>, designing developer ecosystems as <i>Safe Coding</i> and <i>Safe Deployment</i> environments allows us to achieve continuous assurance at scale: It provides confidence that every production release of every application of supported archetypes satisfies desired safety and security invariants.</p>
<h4>References</h4>
<p>1. Adkins, H., Beyer, B., Blankinship, P., Lewandowski, P., Oprea, A., Stubblefield, A. 2020. <i>Building Secure and Reliable Systems: Best Practices for Designing, Implementing, and Maintaining Systems.</i> O'Reilly Media; <a href="https://sre.google/books/building-secure-reliable-systems/">https://sre.google/books/building-secure-reliable-systems/</a>.</p>
<p>2. Corbett, J. C., Dean, J., Epstein, M., Fikes, A., Frost, C., Furman, J. J., Ghemawat, S., Gubarev, A., Heiser, C., Hochschild, P., et al. 2013. Spanner: Google's globally distributed database. <i>ACM Transactions on Computer Systems</i> 31(3), 1–22; <a href="https://dl.acm.org/doi/10.1145/2491245">https://dl.acm.org/doi/10.1145/2491245</a>. </p>
<p>3. CWE. 2023. Stubborn weaknesses in the CWE top 25; <a href="https://cwe.mitre.org/top25/archive/2023/2023_stubborn_weaknesses.html">https://cwe.mitre.org/top25/archive/2023/2023_stubborn_weaknesses.html</a>.</p>
<p>4. CWE. 2023. Top 25 most dangerous software weaknesses; <a href="https://cwe.mitre.org/top25/archive/2023/2023_top25_list.html">https://cwe.mitre.org/top25/archive/2023/2023_top25_list.html</a>.</p>
<p>5. Czapiński, M., Wolafka, R. 2019. Zero Touch Prod: Towards safer and more secure production environments. Usenix; <a href="https://www.usenix.org/conference/srecon19emea/presentation/czapinski">https://www.usenix.org/conference/srecon19emea/presentation/czapinski</a>.</p>
<p>6. Kern, C. 2014. Securing the tangled web. <i>Communications of the ACM</i> 57(9), 38–47; <a href="https://dl.acm.org/doi/10.1145/2643134">https://dl.acm.org/doi/10.1145/2643134</a>.</p>
<p>7. Kotowicz, K. 2024. Trusted Types; <a href="https://w3c.github.io/trusted-types/dist/spec/">https://w3c.github.io/trusted-types/dist/spec/</a>.</p>
<p>8. Leveson, N. 2019. A systems approach to safety and cybersecurity. Usenix; <a href="https://www.usenix.org/conference/srecon19emea/presentation/leveson">https://www.usenix.org/conference/srecon19emea/presentation/leveson</a>.</p>
<p>9. Nokleberg, C., Hawkes, B. 2021. Application frameworks. <i>Communications of the ACM</i> 64(7), 42–49; <a href="https://dl.acm.org/doi/10.1145/3446796">https://dl.acm.org/doi/10.1145/3446796</a>.</p>
<p>10. OWASP. OWASP Top Ten; <a href="https://owasp.org/www-project-top-ten/">https://owasp.org/www-project-top-ten/</a>.</p>
<p>11. Saltzer, J. H., Schroeder, M. D. 1975. The protection of information in computer systems. <i>Proceedings of the IEEE</i> 63(9), 1278–1308; <a href="https://ieeexplore.ieee.org/document/1451869">https://ieeexplore.ieee.org/document/1451869</a>.</p>
<p>12. Seacord, R. C. 2014. <i>The CERT C Coding Standard: 98 Rules for Developing Safe, Reliable, and Secure Systems</i>, second edition. Addison-Wesley Professional.</p>
<p>13. Verma, A., Pedrosa, L., Korupolu, M. R. Oppenheimer, D., Tune, E., Wilkes, J. 2015. Large-scale cluster management at Google with Borg. In <i>Proceedings of the 10th European Conference on Computer Systems (EuroSys)</i>; <a href="https://dl.acm.org/doi/10.1145/2741948.2741964">https://dl.acm.org/doi/10.1145/2741948.2741964</a>. </p>
<p>14. Wang, P., Bangert, J., Kern, C. 2021. If it's not secure, it should not compile: preventing DOM-based XSS in large-scale web development with API hardening. In <i>Proceedings of IEEE/ACM 43rd International Conference on Software Engineering</i>, 1360–1372. <a href="https://dl.acm.org/doi/abs/10.1109/ICSE43902.2021.00123">https://dl.acm.org/doi/abs/10.1109/ICSE43902.2021.00123</a>. </p>
<p>15. Wang, P., Gumundsson, B. A., Kotowicz, K. 2021. Adopting Trusted Types in production web frameworks to prevent DOM-based cross-site scripting: a case study. In <i>IEEE European Symposium on Security and Privacy Workshops</i>, 60–73; <a href="https://research.google/pubs/pub50513/">https://research.google/pubs/pub50513/</a>.</p>
<p>16. Winters, T., Manshreck, T., Wright., H. 2020. <i>Software Engineering at Google: Lessons Learned from Programming over Time</i>. O'Reilly Media; <a href="https://www.oreilly.com/library/view/software-engineering-at/9781492082781/">https://www.oreilly.com/library/view/software-engineering-at/9781492082781/</a>.</p>
<p>17. Young, W., Leveson, N. G. 2014. An integrated approach to safety and security based on systems theory. <i>Communications of the ACM</i> 57(2), 31–35; <a href="https://dl.acm.org/doi/10.1145/2556938">https://dl.acm.org/doi/10.1145/2556938</a>. </p>
<p>&nbsp;</p>
<p><b>Christoph Kern</b> is a principal software engineer in Google's Information Security Engineering organization. His primary focus is on developing scalable, principled approaches to software security.</p>
<p>Copyright © 2024 held by owner/author. Publication rights licensed to ACM.</p>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'8938f97e7d9107fb',t:'MTcxODM1Mzk5Ni4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script>
<p>
<img class="floatLeft" src="img/q stamp_small.jpg" width="26" height="45" alt="acmqueue"><br><br>
<em>Originally published in Queue vol. 22, no. 1</em>&#8212;
<br>
Comment on this article in the <a href="http://portal.acm.org/citation.cfm?id=3648601">ACM Digital Library</a>
</p>
<br/>

<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
<br/>

<br/>
<div class="g-plusone" data-size="small" data-annotation="inline" data-width="120"></div>

<script type="text/javascript">
	addthis_pub             = 'acm';
	addthis_logo            = 'http://queue.acm.org/img/logo_queue_small.gif';
	addthis_logo_background = '#ffffff';
	addthis_logo_color      = '000000';
	addthis_brand           = 'ACM Queue';
	addthis_options         = 'reddit, slashdot, facebook, favorites, email, delicious, digg, technorati, blinklist, furl, myspace, google, live, more';
</script>




<hr noshade size="1" />
More related articles:
<p>
<span>Michael Loftus, Andrew Vezina, Rick Doten, Atefeh Mashatan</span> - <a href="detail.cfm?id=3561826"><b>The Arrival of Zero Trust: What Does it Mean?</b></a>
<br/>
It used to be that enterprise cybersecurity was all castle and moat. First, secure the perimeter and then, in terms of what went on inside that, Trust, but verify. The perimeter, of course, was the corporate network. But what does that even mean at this point? With most employees now working from home at least some of the time and organizations relying increasingly on cloud computing, there is no such thing as a single, enterprise-wide perimeter anymore. And, with corporate security breaches having become a regular news item over the past two decades, trust has essentially evaporated as well.
</p>
<br/>
<p>
<span>Michael Gardiner, Alexander Truskovsky, George Neville-Neil, Atefeh Mashatan</span> - <a href="detail.cfm?id=3467860"><b>Quantum-safe Trust for Vehicles</b></a>
<br/>
In the automotive industry, cars now coming off assembly lines are sometimes referred to as "rolling data centers" in acknowledgment of all the entertainment and communications capabilities they contain. The fact that autonomous driving systems are also well along in development does nothing to allay concerns about security. Indeed, it would seem the stakes of automobile cybersecurity are about to become immeasurably higher just as some of the underpinnings of contemporary cybersecurity are rendered moot.
</p>
<br/>
<hr noshade size="1" />
<hr noshade size="1" />
<p>
<a href="#"><img src="https://queue.acm.org/img/logo_acm.gif" /></a>
<br/>
&copy; ACM, Inc. All Rights Reserved.
</p>
</div>
</body>
</html>