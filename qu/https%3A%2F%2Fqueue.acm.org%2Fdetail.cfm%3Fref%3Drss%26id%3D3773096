<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">



<head>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-20JYM3ZFN0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-20JYM3ZFN0');
</script>



	  
	  <title>A Practical Guide to Transitioning to Memory-Safe Languages - ACM Queue</title>

	  

	  <meta name='description' value='' />
	  <meta name='keywords' value='Security' />

<!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-P52H78L');</script>
<!-- End Google Tag Manager -->

<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="shortcut icon" href="favicon.ico" />

<script type="text/javascript" src="/js/jquery-1.2.6.min.js"></script>
<script type="text/javascript" src="/js/jquery.validate.min.js"></script>
<script type="text/javascript" src="/js/global.js"></script>



<!--
<link rel="alternate" type="application/rss+xml" title="Latest Queue Content RSS 2.0" href="/rss/feeds/latestitems.xml" />
-->
<link rel="alternate" type="application/rss+xml" title="All Queue Content RSS 2.0" href="/rss/feeds/queuecontent.xml" />
<link rel="alternate" type="application/rss+xml" title="Curmudgeon RSS 2.0"     href="/rss/feeds/curmudgeon.xml" />
<link rel="alternate" type="application/rss+xml" title="Opinion RSS 2.0"        href="/rss/feeds/opinion.xml" />
<link rel="alternate" type="application/rss+xml" title="Kode Vicious RSS 2.0"   href="/rss/feeds/kodevicious.xml" />
<link rel="alternate" type="application/rss+xml" title="ACM TechNews RSS"       href="https://www.infoinc.com/acm/TechNews.rss" />
<link rel="alternate" type="application/rss+xml" title="Washington Updates RSS" href="https://usacm.acm.org/weblog2/?feed=rss2" />
<link rel="alternate" type="application/rss+xml" title="RISKS Forum RSS"        href="/rss/feeds/risksforum.xml" />


<link rel="alternate" type="application/rss+xml" title="AI RSS 2.0"        href="/rss/feeds/ai.xml" />

<link rel="alternate" type="application/rss+xml" title="API Design RSS 2.0"        href="/rss/feeds/apidesign.xml" />

<link rel="alternate" type="application/rss+xml" title="Bioscience RSS 2.0"        href="/rss/feeds/bioscience.xml" />

<link rel="alternate" type="application/rss+xml" title="Blockchain RSS 2.0"        href="/rss/feeds/blockchain.xml" />

<link rel="alternate" type="application/rss+xml" title="Business/Management RSS 2.0"        href="/rss/feeds/business/management.xml" />

<link rel="alternate" type="application/rss+xml" title="Compliance RSS 2.0"        href="/rss/feeds/compliance.xml" />

<link rel="alternate" type="application/rss+xml" title="Component Technologies RSS 2.0"        href="/rss/feeds/componenttechnologies.xml" />

<link rel="alternate" type="application/rss+xml" title="Computer Architecture RSS 2.0"        href="/rss/feeds/computerarchitecture.xml" />

<link rel="alternate" type="application/rss+xml" title="Concurrency RSS 2.0"        href="/rss/feeds/concurrency.xml" />

<link rel="alternate" type="application/rss+xml" title="Cryptocurrency RSS 2.0"        href="/rss/feeds/cryptocurrency.xml" />

<link rel="alternate" type="application/rss+xml" title="DSPs RSS 2.0"        href="/rss/feeds/dsps.xml" />

<link rel="alternate" type="application/rss+xml" title="Data RSS 2.0"        href="/rss/feeds/data.xml" />

<link rel="alternate" type="application/rss+xml" title="Databases RSS 2.0"        href="/rss/feeds/databases.xml" />

<link rel="alternate" type="application/rss+xml" title="Debugging RSS 2.0"        href="/rss/feeds/debugging.xml" />

<link rel="alternate" type="application/rss+xml" title="Development RSS 2.0"        href="/rss/feeds/development.xml" />

<link rel="alternate" type="application/rss+xml" title="Distributed Computing RSS 2.0"        href="/rss/feeds/distributedcomputing.xml" />

<link rel="alternate" type="application/rss+xml" title="Distributed Development RSS 2.0"        href="/rss/feeds/distributeddevelopment.xml" />

<link rel="alternate" type="application/rss+xml" title="Education RSS 2.0"        href="/rss/feeds/education.xml" />

<link rel="alternate" type="application/rss+xml" title="Email and IM RSS 2.0"        href="/rss/feeds/emailandim.xml" />

<link rel="alternate" type="application/rss+xml" title="Embedded Systems RSS 2.0"        href="/rss/feeds/embeddedsystems.xml" />

<link rel="alternate" type="application/rss+xml" title="Failure and Recovery RSS 2.0"        href="/rss/feeds/failureandrecovery.xml" />

<link rel="alternate" type="application/rss+xml" title="File Systems and Storage RSS 2.0"        href="/rss/feeds/filesystemsandstorage.xml" />

<link rel="alternate" type="application/rss+xml" title="Game Development RSS 2.0"        href="/rss/feeds/gamedevelopment.xml" />

<link rel="alternate" type="application/rss+xml" title="Graphics RSS 2.0"        href="/rss/feeds/graphics.xml" />

<link rel="alternate" type="application/rss+xml" title="HCI RSS 2.0"        href="/rss/feeds/hci.xml" />

<link rel="alternate" type="application/rss+xml" title="Managing Megaservices RSS 2.0"        href="/rss/feeds/managingmegaservices.xml" />

<link rel="alternate" type="application/rss+xml" title="Mobile Computing RSS 2.0"        href="/rss/feeds/mobilecomputing.xml" />

<link rel="alternate" type="application/rss+xml" title="Networks RSS 2.0"        href="/rss/feeds/networks.xml" />

<link rel="alternate" type="application/rss+xml" title="Object-Relational Mapping RSS 2.0"        href="/rss/feeds/object-relationalmapping.xml" />

<link rel="alternate" type="application/rss+xml" title="Open Source RSS 2.0"        href="/rss/feeds/opensource.xml" />

<link rel="alternate" type="application/rss+xml" title="Patching and Deployment RSS 2.0"        href="/rss/feeds/patchinganddeployment.xml" />

<link rel="alternate" type="application/rss+xml" title="Performance RSS 2.0"        href="/rss/feeds/performance.xml" />

<link rel="alternate" type="application/rss+xml" title="Power Management RSS 2.0"        href="/rss/feeds/powermanagement.xml" />

<link rel="alternate" type="application/rss+xml" title="Privacy and Rights RSS 2.0"        href="/rss/feeds/privacyandrights.xml" />

<link rel="alternate" type="application/rss+xml" title="Processors RSS 2.0"        href="/rss/feeds/processors.xml" />

<link rel="alternate" type="application/rss+xml" title="Programming Languages RSS 2.0"        href="/rss/feeds/programminglanguages.xml" />

<link rel="alternate" type="application/rss+xml" title="Purpose-built Systems RSS 2.0"        href="/rss/feeds/purpose-builtsystems.xml" />

<link rel="alternate" type="application/rss+xml" title="Quality Assurance RSS 2.0"        href="/rss/feeds/qualityassurance.xml" />

<link rel="alternate" type="application/rss+xml" title="RFID RSS 2.0"        href="/rss/feeds/rfid.xml" />

<link rel="alternate" type="application/rss+xml" title="SIP RSS 2.0"        href="/rss/feeds/sip.xml" />

<link rel="alternate" type="application/rss+xml" title="Search Engines RSS 2.0"        href="/rss/feeds/searchengines.xml" />

<link rel="alternate" type="application/rss+xml" title="Security RSS 2.0"        href="/rss/feeds/security.xml" />

<link rel="alternate" type="application/rss+xml" title="Semi-structured Data RSS 2.0"        href="/rss/feeds/semi-structureddata.xml" />

<link rel="alternate" type="application/rss+xml" title="Social Computing RSS 2.0"        href="/rss/feeds/socialcomputing.xml" />

<link rel="alternate" type="application/rss+xml" title="System Administration RSS 2.0"        href="/rss/feeds/systemadministration.xml" />

<link rel="alternate" type="application/rss+xml" title="System Evolution RSS 2.0"        href="/rss/feeds/systemevolution.xml" />

<link rel="alternate" type="application/rss+xml" title="Testing RSS 2.0"        href="/rss/feeds/testing.xml" />

<link rel="alternate" type="application/rss+xml" title="Virtual Machines RSS 2.0"        href="/rss/feeds/virtualmachines.xml" />

<link rel="alternate" type="application/rss+xml" title="Virtualization RSS 2.0"        href="/rss/feeds/virtualization.xml" />

<link rel="alternate" type="application/rss+xml" title="Visualization RSS 2.0"        href="/rss/feeds/visualization.xml" />

<link rel="alternate" type="application/rss+xml" title="VoIP RSS 2.0"        href="/rss/feeds/voip.xml" />

<link rel="alternate" type="application/rss+xml" title="Web Development RSS 2.0"        href="/rss/feeds/webdevelopment.xml" />

<link rel="alternate" type="application/rss+xml" title="Web Security RSS 2.0"        href="/rss/feeds/websecurity.xml" />

<link rel="alternate" type="application/rss+xml" title="Web Services RSS 2.0"        href="/rss/feeds/webservices.xml" />

<link rel="alternate" type="application/rss+xml" title="Workflow Systems RSS 2.0"        href="/rss/feeds/workflowsystems.xml" />

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-6562869-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'stats.g.doubleclick.net/dc.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

<script type="text/javascript">
function plusone_vote( obj ) {
_gaq.push(['_trackEvent','plusone',obj.state]);
}
</script>



<style>
body {
	font-family: jaf-bernino-sans, 'Lucida Grande', 'Lucida Sans Unicode', 'Lucida Sans', Geneva, Verdana, sans-serif;
	color: #333;
	max-width: 100%;
}
div.container p {
	line-height: 1.65em;
}
h1 {
	font-size: 32px;
}
h3 {
	font-size: 18px;
}
h4 {
	font-size: 14px;
}

div.container {
	margin-left: auto;
	margin-right: auto;
}

div {
	margin: 64px;
//	max-width: 800px;
	position: relative;
}

@media only screen and (min-width: 1024px) {
	div {
		max-width: 800px;
	}
}

img {
    max-width: 100%;
    height: auto;
    width: auto\9; /* ie8 */
}
a {
	color: #009;
	text-decoration: none;
}
a:hover {
	text-decoration: underline;
}
hr {
	margin:64px;
}
label {
	font-size: 0.8em;
	color: #666;
}
input {
	color: #999;
}

/* NAVBAR */
.navbar {
//	position: fixed;
	background: #EEEEEE;
	top: -64px;
	z-index: 10000;
	width: 100%;
	clear: both;
	padding: 0px;
	margin: 0px;
	padding-top: 10px;
	padding-left: 10px;
	padding-right: 10px;
}

/*  SECTIONS  */
.section {
	clear: both;
	padding: 0px;
	margin: 0px;
}

/*  COLUMN SETUP  */
.col {
	display: block;
	float:left;
	margin: 1% 0 1% 1.6%;
}
.col:first-child { margin-left: 0; }


/*  GROUPING  */
.group:before,
.group:after {
	content:"";
	display:table;
}
.group:after {
	clear:both;
}
.group {
    zoom:1; /* For IE 6/7 */
}

/*  GRID OF THREE  */
.span_3_of_3 {
	width: 100%;
}
.span_2_of_3 {
	width: 66.1%;
}
.span_1_of_3 {
	width: 32.2%;
}

/*  GO FULL WIDTH AT LESS THAN 480 PIXELS */

@media only screen and (max-width: 480px) {
	.col {
		margin: 1% 0 1% 0%;
	}
}

@media only screen and (max-width: 480px) {
	.span_3_of_3 {
		width: 100%;
	}
	.span_2_of_3 {
		width: 100%;
	}
	.span_1_of_3 {
		width: 100%;
	}
}

.span_2_of_2 {
	width: 100%;
}

.span_1_of_2 {
	width: 49.2%;
}

/*  GO FULL WIDTH AT LESS THAN 480 PIXELS */

@media only screen and (max-width: 480px) {
	.span_2_of_2 {
		width: 100%;
	}
	.span_1_of_2 {
		width: 100%;
	}
}
</style>


<style>
body {
	font-size: 19px;
}
#form-search > .st-default-search-input {
	width: 170px;
  display: inline-block;
  height: 16px;
  padding: 7px 11px 7px 28px;
  border: 1px solid #bbb;
  border: 1px solid rgba(0,0,0,0.25);
  font-weight: 400;
  color: #3B454F;
  font-size: 14px;
  line-height: 16px;
  -webkit-box-sizing: content-box;
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-box-shadow: none;
  -moz-box-shadow: none;
  box-shadow: none;
  font-family: system, -apple-system, BlinkMacSystemFont, "Helvetica Neue", "Lucida Grande", sans-serif;
}


blockquote
{
    color: #666;
    font-size: 1.1em;
    background: none;
    border-left: .2rem solid #d3d3d3;

    display: block;
    padding: 20px 20px 10px 45px;
    margin: 20px 0;
    font-style: italic;

    margin-block-start: 1em;
    margin-block-end: 1em;
    margin-inline-start: 40px;
    margin-inline-end: 40px;

	font-family: Georgia, Palatino, "Palatino Linotype", Times, "Times New Roman", serif;
}

.ldq {
	display: block;
    padding-left: 10px;
    content: "\201C";
    font-size: 60px;
    position: relative;
    left: -50px;
    top: 0;
    height: 0;
    color: #7a7a7a;
}
code {
//	font-size:1.25em;
}
a {overflow-wrap: break-word;}
pre {
	overflow-x: auto;
	white-space: pre-wrap;
	word-wrap: break-word;
}
</style>
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>

<body>
<!-- Google Tag Manager (noscript)
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-P52H78L"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
 End Google Tag Manager (noscript) -->



<div class=container>
	<div class="navbar">
		<form id="form-search" name="searchform" onsubmit="return false;" style='float:right;'>
				<input type="text" class="st-default-search-input">
<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','UyYECD1kdsPnbHJtPyzG','2.0.0');
</script>
				<br />
			
			<a href="issuedetail.cfm?issue=3775067" style='width:150px;font-size:0.7em;'>Current Issue</a> &nbsp; <a href="pastissues.cfm" style='width:150px;font-size:0.7em;'>Past Issues</a> &nbsp; <a href="topics.cfm" style='width:150px;font-size:0.7em;'>Topics</a>
			
		</form>
		<a href='/'><img src='https://queue.acm.org/img/acmqueue_logo.gif' /></a>

	</div>

<!--
<p style='text-align:center;'>
<a href='/app/' target='_new'><img src='/app/2021_03-04_lrg.png' with=90 height=120 style='float:right;width:90px;height:120px;' alt='March/April 2021 issue of acmqueue' /></a>
<b><a href='/app/'>The March/April 2021 issue of acmqueue is out now</a></b>
<br />
<br />
<a href='https://cdn.coverstand.com/3rd_pty/acm/login.html?&btx_i=705849'>Subscribers and ACM Professional members login here</a>
<br clear=all />
<hr style='display:block;color:red;margin:5px;' />
</p>
-->
<br />



<label>November 10, 2025<br /><b><a class="descriptor" href="issuedetail.cfm?issue=3775067">Volume 23, issue 5 </a></b></label>


<p>
<!-- // Check for existence of associated MP3 file-->

 &nbsp;
	
				<a href="https://spawn-queue.acm.org/doi/pdf/10.1145/3773096">
					<img src="img/icon_pdf.png" alt="Download PDF version of this article" />
					PDF
				</a>
			
</p>


 
  <h1 class="hidetitle">A Practical Guide to Transitioning to Memory-Safe Languages</h1> 
  <h2>Turning off the spigot of vulnerabilities: a new strategy for memory safety</h2> 
  <h3>Jeffrey Vander Stoep, Alex Rebert, and Lars Bergstrom</h3> 
  <p>For decades, memory-safety vulnerabilities have been a stubborn and seemingly unavoidable risk of systems software development. But that long-held view is now shifting. Driven by the success of memory-safe languages and reinforced by calls to <a href="https://www.cisa.gov/news-events/news/urgent-need-memory-safety-software-products">action from government agencies</a>, the industry is recognizing that accepting this risk is no longer necessary.</p> 
  <p>Vulnerabilities, once an inevitability of systems programming, should increasingly be seen as a <i>deliberate </i>choice. To be clear, this isn't about blaming developers for individual mistakes. It's about the systemic choice to use a development ecosystem where the accidental introduction of such vulnerabilities is a known and high-probability outcome.</p> 
  <p>Fortunately, data demonstrates that making a better choice does not require daunting multiyear rewrites of existing codebases. Security can be dramatically improved by incrementally shifting the development of just <i>new</i> code to memory-safe languages. If these vulnerabilities can be avoided with low impact on other development goals, then choosing to introduce new ones should increasingly be considered unacceptable, and <i>our goal should be for vulnerabilities to become increasingly impossible to introduce.</i></p> 
  <p>As author James Clear says in his book <i><a href="https://www.penguinrandomhouse.com/books/543993/atomic-habits-by-james-clear/">Atomic Habits</a></i>, "You do not rise to the level of your goals. You fall to the level of your systems." A goal without a system is merely a wish. Transitioning even new development within a codebase to a new language is a complex undertaking, but it is solvable. This article lays out an empirically effective system, covering not only why this shift is so powerful, but also a practical, staged process you can use to make it happen.</p> 
  <p>&nbsp;</p> 
  <h3>The Plateau and the Spigot: Why New Code Matters Most</h3> 
  <p>Memory-safety vulnerabilities represent around <a href="https://www.cisa.gov/news-events/news/urgent-need-memory-safety-software-products">two-thirds of all severe vulnerabilities</a> in major C and C++ codebases. This number has remained at this high plateau across time, codebases, and organizations. It has persisted despite major investments in vulnerability discovery and mitigation from some of the largest tech companies, including Google.</p> 
  <p>Even more concerning, memory-safety vulnerabilities continue to <a href="https://security.googleblog.com/2024/10/safer-with-google-advancing-memory.html">represent an even higher percentage</a> of vulnerabilities exploited "in the wild" to target real victims. This endless cycle of finding and fixing the same kinds of flaws has felt like a battle of attrition that could never be won.</p> 
  <p>Why has durable progress remained so elusive?</p> 
  <p>The answer lies in an observation about the age of vulnerabilities within software. A <a href="https://www.usenix.org/conference/usenixsecurity22/presentation/alexopoulos"> study of vulnerability lifetimes</a> in software projects showed that vulnerabilities are not evenly distributed across the codebase but, rather, <i>highly concentrated in new or recently modified code</i> (see figure 1). This is precisely why lasting progress has remained elusive: New vulnerabilities continue to be introduced at high rates.</p> 
  <img src="https://spawn-queue.acm.org/cms/attachment/html/10.1145/3773096/assets/html/vanderstoep1.png" alt="Figure 1: Distribution of vulnerability lifetimes" /> 
  <br /> Figure 1: Distribution of vulnerability lifetimes 
  <p>Initially, we questioned this finding and wondered if perhaps it applied only to specific kinds of projects such as open-source software or projects with active bug bounties. However, as we replicated these results across a diverse set of projects, including Google's monorepo (the repository that stores the vast majority of Google's code), we have started to understand that this isn't an anomaly, but more likely a fundamental property of software engineering.</p> 
  <p>This leads to a counterintuitive insight that defies some popular anecdotes: The most vulnerable code in your project is not some dusty legacy component, but the code being written today. This is because, like most bugs, vulnerabilities have a half life. The longer code exists and is exercised, the more likely its flaws are to be found and fixed, leaving the freshest code with the highest concentration of bugs.</p> 
  <p>This insight reorients our focus on how to achieve lasting results. The traditional security approach of finding and fixing bugs is akin to bailing water from a sinking boat without ever patching the hole—a Sisyphean task requiring constant effort. This is often fueled by the common but unfulfilled hope that the next mitigation will be the one to finally solve C's and C++'s memory safety. The data shows that the highest-leverage strategy is to turn off this vulnerability spigot. We must stop creating these bugs in the first place.</p> 
  <p>&nbsp;</p> 
  <h3>A New Strategy: Securing New Code by Default</h3> 
  <p>The industry's traditional approach to memory safety depends on developer discipline, code reviews, and post-hoc analysis to find and fix vulnerabilities. This approach places an unrealistic burden on developers: We are unfairly asking developers to walk a tightrope without a net. With this approach, memory safety was largely a manual process, where good developers are expected to avoid introducing vulnerabilities.</p> 
  <p>At Google, we've learned that the most effective way to eliminate entire classes of vulnerabilities is to stop treating security as a matter of developer discipline based on the unreasonable assumption that developers never make mistakes and instead build it into the development platform. This is the core principle of a safe coding system: a development ecosystem where language features, APIs, and tooling combine to prevent the introduction of vulnerabilities with high assurance. The transition to memory-safe languages such as Rust represents the application of this same proven, system-level strategy to the longstanding challenge of memory safety. Rather than asking developers to perfectly remember and apply safety rules, <i>Rust enforces them by design</i>.</p> 
  <p>This new strategy consciously departs from the traditional model of retroactively hardening legacy components. Hardening remains a valuable tactic for managing risk in an existing system, but adopting a safe-by-design language for new code is a strategic change to the system itself. It's the highest-leverage way to alter the security trajectory of a project, focusing on changing the future of development, not rewriting the past.</p> 
  <p>&nbsp;</p> 
  <h3>Outcomes</h3> 
  <p>The effectiveness of focusing on prevention has already been observed internally at Google for vulnerability classes such as XSS and SQLi. What was unexpected, however, was the velocity with which this approach proved effective against memory-safety vulnerabilities in the Android project, which motivated an evaluation of why the approach works so quickly. The progress in security outcomes has been remarkable: Memory-safety vulnerabilities, which historically caused 70 percent of Android's vulnerabilities, <a href="https://security.googleblog.com/2024/09/eliminating-memory-safety-vulnerabilities-Android.html">fell to just 24 percent in 2024</a> (see figure 2) and are continuing to drop.</p> 
  <img src="https://spawn-queue.acm.org/cms/attachment/html/10.1145/3773096/assets/html/vanderstoep2.png" alt="Figure 2: Memory-safe vulnerabilities in Android" /> 
  <br /> Figure 2: Memory-safe vulnerabilities in Android 
  <p>This decrease was achieved by gradually transitioning the language used for new development. Early progress appeared modest: After two years, Rust constituted less than one percent of Android's first-party code. As we've seen, however, the total code percentage is the wrong metric. Looking at <i>new</i> code specifically, a more compelling story emerges. After two years, around 10 percent of new native code was in Rust, growing exponentially through a doubling every 1.5 years.</p> 
  <p>This growth eventually reached an inflection point. Just 2.5 years after hitting 10 percent, new Rust code surpassed new C++ code (see figure 3). This trend was driven by both increased Rust adoption and a corresponding decrease in use of C++, since projects that would have previously been done in C++ were using Rust instead.</p> 
  <img src="https://spawn-queue.acm.org/cms/attachment/html/10.1145/3773096/assets/html/vanderstoep3.png" alt="Figure 3: New lines of code between C++ and Rust" /> 
  <br /> Figure 3: New lines of code between C++ and Rust 
  <h4>Beyond Security: Productivity</h4> 
  <p>The most powerful finding, however, is that these security improvements do not come at the cost of other engineering goals. In fact, the opposite is true. Adopting Rust has led to measurable improvements in <a href="https://dora.dev/guides/dora-metrics-four-keys/">key software delivery metrics</a> linked to organizational performance and productivity by Google's DORA (DevOps Research and Assessment) research. It is important to clarify that this data comes from years of real-world Android development and not from a controlled scientific experiment.</p> 
  <p>A key metric for software delivery is the change fail percentage—the proportion of changes that cause a failure in production requiring a fix or rollback. Our data shows a clear and consistent pattern: The rollback rate for Rust changes has been significantly lower than for C++ changes of a comparable size (see figure 4a). For large changes in 2024, Rust was more than four times less likely to be rolled back than C++. This lower failure rate has remained relatively stable over time, even as the volume of new Rust code has grown to surpass that of C++, resulting in higher confidence that the language itself is a key factor in accelerating software delivery.</p> 
  <img src="https://spawn-queue.acm.org/cms/attachment/html/10.1145/3773096/assets/html/vanderstoep4a.png" alt="Figure 4a: PR rollback rate over time in Android" /> 
  <br /> Figure 4a: PR rollback rate over time in Android 
  <p>Beyond stability, there have also been gains in development velocity. Change lead time, the time it takes for a code commit to be successfully deployed, is a critical measure of efficiency. One of the largest factors in this metric is often code-review latency. Our data shows a fascinating trend: As our developer community has gained experience with Rust, the time required for code reviews has decreased (see figure 4b). Rust changes tend to go through fewer revisions and spend less time in the review cycle, with an approximately two times faster median code review in 2024 compared with C++.</p> 
  <img src="https://spawn-queue.acm.org/cms/attachment/html/10.1145/3773096/assets/html/vanderstoep4b.png" alt="Figure 4b: PR review time over time in Android" /> 
  <br /> Figure 4b: PR review time over time in Android 
  <p>These positive outcomes demonstrate that choosing a memory-safe language is not about making a tradeoff between security and productivity. We are not sacrificing quality for velocity or productivity for security. We are improving across all of these metrics simultaneously. The results were achieved while reducing costs associated with sandboxing, fuzzing, and the engineering hours spent triaging and patching bugs. Using a better tool allows for fewer tradeoffs, resulting in better software and, ultimately, a better product.</p> 
  <p>&nbsp;</p> 
  <h3>A Practical Guide to Rust Adoption: Harnessing Compound Growth</h3> 
  <p>There is a temptation, when introducing a new language, to pursue an aggressive timeline to justify the investment with short-term gains. Such an approach, fixated on overly ambitious goals, or rapid, sweeping change, invariably carries elevated risks of failure and can actively disincentivize future adoption by disrupting roadmaps and competing with other business objectives.</p> 
  <p>A more powerful strategy, the one that proved so effective for Android, is to treat language adoption as <i>a long-term investment in sustainable, compounding growth</i> that supports other business objectives instead of competing with them. This approach <i>patiently</i> <i>accepts</i> initially lower absolute numbers to provide the necessary time for the new language to establish a foothold, build momentum, and achieve critical mass.</p> 
  <p>The initial progress will likely appear frustratingly slow. Each successful project, however, is a "dividend" of community growth, confidence, expertise, and capabilities, which is reinvested to fund the next, more ambitious project. This creates a positive feedback loop where success breeds more success. The result is an exponential adoption curve that fundamentally transforms the security and productivity of the entire project.</p> 
  <p>So, how can sustainable language adoption and growth be achieved? The Android project provides a compelling example, having successfully used a multistage process that is now being adopted and adapted across other parts of Google to scale Rust usage. Each stage of this process focuses on specific, achievable objectives, critically enabled by providing adequate support while minimizing disruption to ongoing development. Briefly, these stages are:</p> 
  <p><b><i>0. Organizational alignment</i></b> – Get buy-in and initial funding for Rust.</p> 
  <p><b><i>1. Enablement team</i></b> – Build a customer-focused team whose mission is the success of its customers.</p> 
  <p><b><i>2. Initial support</i></b> – Focus on core needs and build basic support for common use cases.</p> 
  <p><b><i>3. Pilots</i></b> – Validate support and build confidence by successfully shipping pilot projects.</p> 
  <p><b><i>4. Rust by exception</i></b> – Control growth by approving new projects and expanding support.</p> 
  <p><b><i>5. General availability</i></b> – Remove restrictions as organic adoption meets demand.</p> 
  <p><b><i>6. Rust recommended</i></b> – Encourage wider adoption by addressing blockers for hesitant teams.</p> 
  <p><b><i>7. (Optional) C/C++ by exception</i></b> – Make C and C++ the exception, guiding suitable projects to use Rust instead.</p> 
  <p>&nbsp;</p> 
  <h4>Stage 0: Gain organizational alignment</h4> 
  <p>Before any code is written, a successful adoption strategy begins with a deliberate decision. There must be organizational recognition that language transition for new code is a strategic objective and a commitment to fund the initial experimental stages (e.g., stages 1–3), contingent on their success. This early buy in ensures that if the pilots prove fruitful, the effort won't stall because of a lack of strategic support.</p> 
  <h4>Stage 1: Build a customer-focused support team</h4> 
  <p>Before detailing the stages, let's talk about who implements them. An important factor in Android's successful adoption was the creation of a small dedicated Rust team whose mission was the success of their customers. This is not a traditional <i>infrastructure</i> team; it is an <i>enablement</i> team.</p> 
  <p>This team's effectiveness is not measured by the code they write but by their customers' ability to ship high-quality Rust code successfully. Importantly, that team is not designed to scale linearly with the number of Rust developers; its goal is to develop a self-sustaining ecosystem. The team's focus evolves with each stage, from implementing basic tooling to proactively consulting with hesitant teams, but their core mission remains the same: Serve the customer. This team is the engine for the entire adoption process.</p> 
  <h4>Stage 2: Initial support – lay the foundation</h4> 
  <p>The goal of this stage is to build an MVP for Rust adoption. The aim is not to solve every problem but to provide <i>just</i> enough infrastructure to unblock the first one or two pilot projects. Over-engineering support here is a common failure mode; it is far more valuable to ship working code and gain practical experience than to strive for comprehensive support from the outset.</p> 
  <p>Key questions to answer:</p> 
  <p>• <b><i>Build integration</i></b> – How does Rust fit into the project's primary build system? (See Android's design consideration <a href="https://security.googleblog.com/2021/05/integrating-rust-into-android-open.html">in a 2021 Google Security Blog post</a>.)</p> 
  <p>• <b><i>Interop</i></b> – What is the "good enough" path for Rust to call existing C/C++ code and vice versa? In Android, we surveyed our needs and concluded that <a href="https://security.googleblog.com/2021/06/rustc-interop-in-android-platform.html">existing tooling was likely to cover the majority</a> of our use cases. For a limited number of cases where it was not good enough, we accepted the development costs of writing custom bindings between Rust and C++.</p> 
  <p>• <b><i>Tooling</i></b> – Is the language supported in developer environments (e.g., editors, debuggers, CI, production observability, etc.)? We worked closely with pilot customers to ensure we were building things specifically to unblock pilots.</p> 
  <p>• <b><i>Frameworks and libraries</i></b> – What essential, project-specific frameworks or libraries must be accessible from Rust? For example, the Android project required support for our IPC (interprocess communication) system, logging, and metrics collection.</p> 
  <p>&nbsp;</p> 
  <p><i>Get out of this stage as quickly as possible.</i> The exit criterion for this phase is simple: One or more pilot projects are identified, and they confirm that the initial support is likely to meet their needs.</p> 
  <h4>Stage 3: Pilots – build confidence through success</h4> 
  <p>The primary goal of the pilot stage is to generate tangible proof points for Rust's viability and value. Prototypes do not build confidence; shipping features does. A successful pilot project serves as undeniable evidence of Rust's value and the support team's ability to deliver.</p> 
  <p>Nothing succeeds like success—careful selection of low-risk pilots can be important. Be picky and choose projects that align well with the support capabilities established in the initial phase. Projects can fail for numerous reasons unrelated to new language adoption, but early on, the new language may unfairly bear the blame. Selecting small to moderately sized projects can help mitigate the risk of failure, and having more than one pilot project running concurrently can further reduce overall risk. It can be helpful to avoid mission-critical projects such as a major feature launch or foundational system so that answering the key questions just mentioned can take priority.</p> 
  <p>It's important to select pilot customers that are aligned with validating that the new Rust support is a key deliverable and that some flexibility may be required on delivery timelines because of unforeseen gaps in support. While rewrites are generally discouraged, rewriting a small, well-understood component can serve as a good pilot, as it allows for a direct comparison against an existing implementation.</p> 
  <p>The exit criteria for this phase are when the pilots have successfully shipped and achieved their defined objectives. This signifies that the new language has proven its value in a practical setting and that the support infrastructure is capable of handling real-world projects.</p> 
  <h4>Stage 4: Rust by exception – controlled growth and expansion</h4> 
  <p>With successful pilots shipped, demand for Rust will likely begin to grow. The goal of this stage is to manage that growth deliberately, ensuring that the "supply" of support can meet the demand. The focus is on quality of adoption over quantity.</p> 
  <p>A key focus during this stage is to have a lightweight process for teams to propose Rust projects and for approving which projects may use Rust. The nature of this process depends on an organization's culture: In a company with a formal language strategy, this aligns with existing governance; in a more decentralized environment, this may simply be a way for the Rust enablement team to accept customers they are willing to support and to manage their own capacity.</p> 
  <p>This gatekeeping mechanism allows the central support team to manage the influx of new adopters and ensure that each project has the necessary resources and support to succeed. Approval criteria might include the availability of adequate support from the Rust team, how well the project's needs align with the existing support, and the value of using Rust in the project when compared with other proposals.</p> 
  <p>During this stage, continue expanding the number of teams, projects, and use cases that can be supported. Address new gaps in support as they arise from the increasing diversity of projects adopting the language. This might necessitate further development of tools, libraries, or <a href="https://google.github.io/comprehensive-rust/">training materials</a>.</p> 
  <p>At this stage, it's important for scalability to expand the support systems beyond just the core Rust support team. This could involve creating dedicated communication channels, such as a chat room, where developers can ask questions, share knowledge, and receive timely assistance. Building a community helps foster organic growth and peer support.</p> 
  <p>The exit criterion for this phase is when project proposals are being routinely approved, indicating a maturing language support and sufficient support capacity.</p> 
  <h4>Stage 5: Rust general availability – remove restrictions</h4> 
  <p>At this stage, the training wheels come off. With mature tooling and a growing support community, teams within the organization are now free to adopt Rust without needing special approval, as long as their technical needs are met. The primary goal shifts from controlling growth to enabling it at scale.</p> 
  <p>The main focus is now on ensuring the support systems can handle the increased load and customer teams are receiving sufficient support, ideally without scaling the support team itself. Even with broader adoption, maintaining a high level of support remains important for ensuring continued success and addressing any unforeseen challenges. This might involve refining support processes and leveraging community support.</p> 
  <p>The exit criterion for this stage is when organic demand is met. This demonstrates that the teams who were naturally inclined to adopt Rust have done so, and a more proactive approach is needed to convince the next wave of adopters.</p> 
  <h4>Stage 6: Rust Recommended – generate additional demand</h4> 
  <p>The goal of this stage is to proactively generate new demand and move from the <i>early adopters</i> to the <i>early majority</i>. Rust is no longer just available; it is now the recommended choice for new development where it is a good technical fit.</p> 
  <p>The Rust enablement team must now act as product managers, actively understanding and winning over their markets. The focus during this phase should be on understanding the hesitancy or blockers preventing more widespread adoption. This might involve conducting surveys, holding discussions with teams, and analyzing adoption patterns. Once these blockers are identified, the Rust team needs to work on addressing them.</p> 
  <p>The exit criterion for this stage is when the organization has addressed most blockers for most teams and has a clear understanding of where exceptions to the new language recommendation might need to be made.</p> 
  <h4>Stage 7: (Optional) C/C++ by exception</h4> 
  <p>This final stage represents a significant policy and cultural shift. It requires careful consideration and organizational alignment that transitioning languages is an objective. If such an agreement cannot be reached, implementing this stage is not advisable.</p> 
  <p>The goal is not to eliminate C++ but to make Rust the <i>default</i> path for new projects and features, requiring a deliberate choice to use something else, even if some of the dependencies or changes are in C/C++. The aim is to make the safe choice the default easy choice, while recognizing that there are going to continue to be valid reasons for using C/C++, such as the need to make changes within an existing codebase. </p> 
  <p>It's helpful to document valid automatic exceptions to this policy. There will invariably be legitimate reasons why a project might need to be in C/C++ (e.g., its library needs to target architectures that do not have Rust compiler support). Language familiarity alone, however, should not be a valid reason to continue using C/C++ for new projects. Developers should be expected to learn new technologies as part of their job. The availability of training can help with this.</p> 
  <p>Focus on having a simple, well-documented process for teams to request an exception to this policy based on business or technical needs. This serves the dual purpose of ensuring the language policy remains subordinate to critical business requirements while also helping to build organizational confidence and alignment that such a policy is generally feasible. It also provides additional data on areas where Rust support should be improved.</p> 
  <p>Ideally, an exception should not be a free pass. It should come with an explicit acknowledgment of the costs required to mitigate the risks of using a memory-unsafe language. Projects granted an exception to use C/C++ should be required, unless explicitly exempted, to enable and maintain mitigations—for example, strict sandboxing and hardening such as bounds checking. This makes the tradeoffs clear; the team requesting the exception must confirm that their project can bear the engineering and runtime overhead that these security controls will durably impose.</p> 
  <p>This stage is expected to become a steady state. The goal is not necessarily to eliminate the old language entirely but rather to establish the new language as the default choice for new development. </p> 
  <p>&nbsp;</p> 
  <h3>Conclusion</h3> 
  <p>Traditional approaches to memory safety have often amounted to best-effort defect discovery after the fact, and sometimes more advanced strategies focused on threat modeling: identifying critical code, applying interventions, and repeating the cycle as the codebase evolves. </p> 
  <p>While this approach is a valuable part of a defense-in-depth strategy, it is fundamentally flawed as a primary strategy. It traps teams in a reactive and never-ending cycle of treating symptoms with solutions empirically shown to be insufficiently complete without ever addressing the underlying cause.</p> 
  <p>Focusing on the growth of memory-safe languages is a fundamentally different, proactive approach. It commoditizes safety, making it the default for new development, not an expensive feature to retrofit onto a few components. While these two strategies can be paired, a safe-by-default foundation allows threat modeling to build upon a secure base rather than constantly shoring it up.</p> 
  <p>The journey to memory safety is not about the impossible task of "rewriting it all" in memory-safe languages, but it is about the practical, high-impact strategy of securing new code. Android's experience demonstrates an incremental transition is not only achievable, but also remarkably effective. By following a staged, customer-focused approach, many, if not most, organizations can also begin building a future where software is secure by design.</p> 
  <p>&nbsp;</p> 
  <p><b>Jeff Vander Stoep</b> is a software engineer on the Android security team at Google. He has spent the past 11 years defining Android's security model, enforcing it through security architecture, and bolstering its resilience with a focus on reducing the prevalence and reachability of vulnerabilities.</p> 
  <p><b>Alex Rebert</b> is an engineer at Google, where he focuses on memory safety. Previously, he cofounded ForAllSecure and led the creation of Mayhem, the autonomous system that won the 2016 DARPA Cyber Grand Challenge. He was recognized by <i>MIT Technology Review</i> as one of the 35 Innovators Under 35 and by <i>Forbes's</i> 30 Under 30.</p> 
  <p><b>Lars Bergstrom</b> is a director of engineering at Google on the Android team, working on platform tools and libraries. He manages the tools that update the Android operating system as well as the Java, C/C++, and Rust toolchains and supporting libraries. He also serves as Google's corporate director to RISC-V International and is on the advisory board for the Lean Research Organization.</p> 
  <p>&nbsp;</p> 
  <p>Copyright © 2025 held by owner/author. Publication rights licensed to ACM.</p>  
 <script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9a9897f1c9c405b7',t:'MTc2NDk5MDY2MS4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script> 

	<p>
	
		<img class="floatLeft" src="img/q stamp_small.jpg" width="26" height="45" alt="acmqueue"><br><br>
	
	<em>Originally published in Queue vol. 23, no. 5</em>&#8212;
 	<br>
	Comment on this article in the <a href="http://portal.acm.org/citation.cfm?id=3773096">ACM Digital Library</a>
	
	</p>
	



<br />
<!--
<a href="https://twitter.com/share" class="twitter-share-button" data-via="ACMQueue">Tweet</a>
-->
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

<br />

<!--
<fb:like></fb:like>
-->

<br />

<div class="g-plusone" data-size="small" data-annotation="inline" data-width="120"></div>

<!-- these get hooked up to js events -->
<script type="text/javascript">
	addthis_pub             = 'acm';
	addthis_logo            = 'http://queue.acm.org/img/logo_queue_small.gif';
	addthis_logo_background = '#ffffff';
	addthis_logo_color      = '000000';
	addthis_brand           = 'ACM Queue';
	addthis_options         = 'reddit, slashdot, facebook, favorites, email, delicious, digg, technorati, blinklist, furl, myspace, google, live, more';
</script>

<!-- FB Like -->
<!--
<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "connect.facebook.net/en_US/all.js#xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

<div id="fb-root"></div>
-->

<!-- Place this tag after the last +1 button tag. -->

<!--
<script type="text/javascript">
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script>

<br />
<script src="https://connect.facebook.net/en_US/all.js#xfbml=1"></script>

<script>
FB.Event.subscribe('edge.create', function(targetUrl) {
  _gaq.push(['_trackSocial', 'facebook', 'like', targetUrl]);
});
</script>
-->



<hr noshade size=1 />




More related articles:

	  <p>
	  <span>Louis Dionne, Alex Rebert, Max Shavrick, Konstantin Varlamov</span> - <a href="detail.cfm?id=3773097"><b>Practical Security in Production</b></a>
	  <br />
	  The challenge of improving the memory safety of the vast landscape of existing C++ code demands pragmatic solutions. Standard library hardening represents a powerful and practical approach, directly addressing common sources of spatial safety vulnerabilities within the foundational components used by nearly all C++ developers. Our collective experience at Apple and Google demonstrates that significant safety gains are achievable with surprisingly minimal performance overhead in production environments. This is made possible by a combination of careful library design, modern compiler technology, and profile-guided optimization.
	  </p>
	  <br />

	  <p>
	  <span>Christoph Kern</span> - <a href="detail.cfm?id=3773098"><b>Safe Coding</b></a>
	  <br />
	  Safe coding embodies a modular, compositional approach to building and reasoning about the safety of large, complex systems. Difficult and subtle reasoning about the safety of abstractions is localized to their implementations; the safety of risky operations within an abstraction must rely solely on assumptions supported by the abstraction's APIs and type signatures. Conversely, the composition of safe abstractions with safe code is automatically verified by the implementation language's type checker. While not a formal method itself, safe coding is grounded in principles and techniques from rigorous, formal software verification.
	  </p>
	  <br />

	  <p>
	  <span>Andrew Lilley Brinker</span> - <a href="detail.cfm?id=3773095"><b>Memory Safety for Skeptics</b></a>
	  <br />
	  The state of possibility with memory safety today is similar to the state of automobile safety just prior to the widespread adoption of mandatory seat-belt laws. As car manufacturers began to integrate seat belts as a standard feature across their model lines and states began to require that drivers wear seat belts while driving, the rate of traffic fatalities and severity of traffic-related injuries dropped drastically. Seat belts did not solve automobile safety, but they credibly improved it, and at remarkably low cost.
	  </p>
	  <br />

	  <p>
	  <span>Jinnan Guo, Peter Pietzuch, Andrew Paverd, Kapil Vaswani</span> - <a href="detail.cfm?id=3665220"><b>Trustworthy AI using Confidential Federated Learning</b></a>
	  <br />
	  The principles of security, privacy, accountability, transparency, and fairness are the cornerstones of modern AI regulations. Classic FL was designed with a strong emphasis on security and privacy, at the cost of transparency and accountability. CFL addresses this gap with a careful combination of FL with TEEs and commitments. In addition, CFL brings other desirable security properties, such as code-based access control, model confidentiality, and protection of models during inference. Recent advances in confidential computing such as confidential containers and confidential GPUs mean that existing FL frameworks can be extended seamlessly to support CFL with low overheads.
	  </p>
	  <br />


<hr noshade size=1 />





<hr noshade size=1 />

	<p>
	<a href='#'><img src='https://queue.acm.org/img/logo_acm.gif' /></a>
	<br />
	&copy; ACM, Inc. All Rights Reserved.
	</p>

</div>



<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9a9897eebf79101e',t:'MTc2NDk5MDY2MS4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>